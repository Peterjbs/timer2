<!DOCTYPE html>
<html lang="en">
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="theme-color" content="#0b0e14">
  <meta charset="utf-8" />
  <title>Quadrant Timers ‚Äî Full Ferocity (v16 Challenges)</title>
  <style>
    :root{ --bg:#0b0e14; --fg:#eaeef5; --muted:#9aa4b2; --panelBorder:#1a2030; --dockH:64px; }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
    .dock{position:fixed; left:0; right:0; top:0; height:var(--dockH); display:flex; align-items:center; gap:.5rem; padding:0 .75rem; background:#0f1422; border-bottom:1px solid var(--panelBorder); z-index:100}
    .dock .spacer{flex:1}
    .dock button, .dock label{background:#141b2b; color:var(--fg); border:1px solid var(--panelBorder); padding:.5rem .7rem; border-radius:.6rem; cursor:pointer; font-weight:600}
    .dock input[type=file]{display:none}
    .hint{opacity:.9; font-size:.9rem}
    .stage{position:fixed; left:0; right:0; top:var(--dockH); bottom:0; display:grid; grid-template-columns:1fr 1fr; grid-template-rows:1fr; background:black; transition: filter .25s ease; gap:1px}
    .quadrant{position:relative; overflow:hidden; border:1px solid var(--panelBorder); transition: transform .25s ease, opacity .2s ease, filter .2s ease}
    .quadrant.dimmed{opacity:.22; filter:grayscale(.8) brightness(.55)}
    .quadrant .quad-video{width:100%; height:100%; object-fit:cover; background:black; transform-origin:center; transition: transform .25s ease}
    .overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center; pointer-events:none; opacity:0; transition: opacity .12s ease; z-index: 200;}
    .overlay.show{opacity:1;}
    .overlay .inner{padding:0; color:white; text-shadow:0 4px 20px rgba(0,0,0,.9), 0 0 60px var(--themeAccent, transparent); text-align:center; border-radius:0; background:transparent; box-shadow:none; width:100%; height:100%;}
    .display-xxl{font-size:clamp(8rem, 25vw, 20rem); font-weight:900; letter-spacing:-.02em; color:var(--themeAccent, white); text-shadow:0 0 40px var(--themeBase, transparent), 0 8px 30px rgba(0,0,0,.9); line-height:1; text-transform:uppercase;}
    .display-lg{font-size:clamp(3rem, 10vw, 8rem); font-weight:800; opacity:.95; color:var(--themeAccent, white); text-transform:uppercase; letter-spacing:.1em;}
    /* Timer in top left corner */
    .nextTimer{position:absolute; left:.5rem; top:.5rem; right:auto; bottom:auto; min-width:8ch; font-size:clamp(.9rem, 2vw, 1.2rem); padding:.3rem .5rem; background:rgba(5,5,10,.85); box-shadow:0 4px 16px rgba(0,0,0,.6); border-radius:.4rem; display:flex; align-items:center; justify-content:center; border:1px solid var(--themeBase, var(--panelBorder)); z-index:80;}
    .nextTimer .bar{position:absolute; left:0; bottom:0; height:3px; width:0%; background:var(--themeAccent, #8ab4ff); border-radius:0 0 .6rem .6rem; transition:width .18s linear}
    .tally{position:absolute; top:.5rem; left:.5rem; right:.5rem; padding:.4rem .6rem; border:1px solid var(--panelBase, var(--panelBorder)); border-radius:.6rem; background:rgba(0,0,0,.75); font-size:1.15rem; letter-spacing:.08em; font-weight: 600; max-height: 3rem; overflow-y: auto; line-height: 1.4; z-index: 70;}
    .task-buttons{position:absolute; bottom:5rem; left:50%; transform:translateX(-50%); display:none; gap:1rem; z-index:250; pointer-events:auto;}
    .task-buttons.show{display:flex;}
    .task-buttons button{font-size:clamp(2rem, 5vw, 4rem); padding:.8rem 1.5rem; border-radius:1rem; border:3px solid white; cursor:pointer; font-weight:900; transition:transform .1s, opacity .1s;}
    .task-buttons button:hover{transform:scale(1.05);}
    .task-buttons button:active{transform:scale(0.95);}
    .btn-task-fail{background:#ff4444; color:white;}
    .btn-task-complete{background:#44ff44; color:white;}
    .manual-controls{position:absolute; bottom:1.25rem; left:50%; transform:translateX(-50%); display:flex; gap:.75rem; z-index:260;}
    .manual-controls button{background:rgba(0,0,0,.75); color:#fff; border:2px solid rgba(255,255,255,.25); border-radius:.5rem; padding:.4rem .9rem; font-weight:700; cursor:pointer; font-size:1rem; letter-spacing:.05em;}
    .manual-controls button:hover{background:rgba(255,255,255,.15);}
    .manual-controls .btn-manual-skip{border-color:#ff7676;}
    .manual-controls .btn-manual-shuffle{border-color:#7ac4ff;}
    .chooseTint{position:absolute; inset:0; opacity:0; transition:opacity .18s ease, transform .18s ease; pointer-events:none; display:flex; flex-direction:column; align-items:center; justify-content:center; color:#fff; text-shadow:0 2px 12px rgba(0,0,0,.9)}
    .quadrant.choose-phase .chooseTint{opacity:1; pointer-events: auto;}
    .chooseTitle{font-weight:900; font-size:clamp(1.2rem, 4vw, 2.4rem); letter-spacing:.02em; margin-bottom:.35rem}
    .emojisPlan{font-size:clamp(1.1rem,2.6vw,1.9rem); letter-spacing:.22rem; margin-top:.35rem}
    .btn-change-theme { pointer-events:auto; cursor:pointer; font-size:1rem; padding:.5rem 1rem; margin-top:1rem; border-radius:.5rem; background:rgba(255,255,255,.1); color:white; border:1px solid white; font-weight: 600; }
    .btn-change-theme:hover { background:rgba(255,255,255,.2); }
    .clip-option:hover { border-color:rgba(255,255,255,.5) !important; }
    .clip-option.selected { border-color:#44ff44 !important; box-shadow:0 0 20px #44ff44; }
    .selectBadge{position:absolute; top:.5rem; left:.5rem; background:var(--themeBase, rgba(0,0,0,.6)); border:1px solid rgba(255,255,255,.25); padding:.15rem .45rem; border-radius:.4rem; font-weight:800; pointer-events:none}
    .quadrant.selected .selectBadge{background:rgba(46,204,113,.9); border-color:rgba(255,255,255,.7)}
    .quadrant.selected .selectBadge::after{content:' IN PLAY';}
    .quadrant:not(.selected) .selectBadge::after{content:' TAP TO PLAY';}
    .quadrant.choose-phase{cursor:pointer}
    .quadrant.choose-phase:hover .chooseTint{transform:scale(1.02)}
    .qcontrols{position:absolute; right:.4rem; top:.4rem; z-index:5; display:flex; gap:.25rem}
    .qcontrols button{background:rgba(0,0,0,.6); color:#fff; border:1px solid rgba(255,255,255,.2); padding:.2rem .45rem; border-radius:.4rem; cursor:pointer; font-weight:700}
    .qcontrols button:hover{background:rgba(255,255,255,.1)}
    .qcontrols .active{background:rgba(46,204,113,.9)}
    .corners{position:absolute; inset:0; pointer-events:none;}
    .corners::before{content:""; position:absolute; inset:0; background:
      radial-gradient(240px 240px at 0% 0%, var(--pulseColor,transparent), transparent 60%),
      radial-gradient(240px 240px at 100% 0%, var(--pulseColor,transparent), transparent 60%),
      radial-gradient(240px 240px at 0% 100%, var(--pulseColor,transparent), transparent 60%),
      radial-gradient(240px 240px at 100% 100%, var(--pulseColor,transparent), transparent 60%);
      opacity:0; transition:opacity .15s ease; filter:blur(2px); mix-blend-mode:screen}
    .quadrant.bulge .corners::before{opacity:1}
    .quadrant.bulge{transform:scale(1.06); box-shadow:0 0 0 2px var(--pulseColor,transparent), 0 0 40px 10px rgba(255,255,255,.07), 0 0 28px 8px var(--pulseColor,transparent)}
    .quadrant.bulge .quad-video{transform:scale(1.02)}
    .phaseTint{position:absolute; inset:0; pointer-events:none; opacity:0; transition:opacity .12s ease; mix-blend-mode:overlay}
    .phaseTint.show{opacity:.22}
    
    /* Theme-specific text positioning */
    .theme-neon .overlay[data-type="ready"] .inner { align-items:flex-start; padding-top:15vh; }
    .theme-neon .overlay[data-type="light"] .inner { align-items:center; justify-content:center; }
    .theme-neon .overlay[data-type="fill"] .inner { align-items:flex-end; padding-bottom:15vh; }
    .theme-neon .overlay[data-type="sniff"] .inner { align-items:center; justify-content:flex-start; padding-left:10vw; }
    .theme-neon .overlay[data-type="action"] .inner { align-items:flex-start; justify-content:flex-end; padding:5vh 5vw; }
    
    .theme-inferno .overlay[data-type="ready"] .inner { align-items:flex-end; padding-bottom:10vh; }
    .theme-inferno .overlay[data-type="light"] .inner { align-items:flex-start; padding-top:10vh; }
    .theme-inferno .overlay[data-type="fill"] .inner { align-items:center; justify-content:flex-end; padding-right:10vw; }
    .theme-inferno .overlay[data-type="sniff"] .inner { align-items:flex-start; justify-content:flex-start; padding:5vh 5vw; }
    .theme-inferno .overlay[data-type="action"] .inner { align-items:center; }
    
    .theme-void .overlay[data-type="ready"] .inner { align-items:center; justify-content:flex-start; padding-left:8vw; }
    .theme-void .overlay[data-type="light"] .inner { align-items:center; }
    .theme-void .overlay[data-type="fill"] .inner { align-items:center; justify-content:flex-end; padding-right:8vw; }
    .theme-void .overlay[data-type="sniff"] .inner { align-items:flex-end; padding-bottom:12vh; }
    .theme-void .overlay[data-type="action"] .inner { align-items:flex-start; padding-top:12vh; }
    
    .theme-toxic .overlay[data-type="ready"] .inner { align-items:flex-start; justify-content:flex-end; padding:8vh 8vw; }
    .theme-toxic .overlay[data-type="light"] .inner { align-items:flex-end; justify-content:flex-start; padding:8vh 8vw; }
    .theme-toxic .overlay[data-type="fill"] .inner { align-items:center; }
    .theme-toxic .overlay[data-type="sniff"] .inner { align-items:flex-start; padding-top:8vh; }
    .theme-toxic .overlay[data-type="action"] .inner { align-items:flex-end; padding-bottom:8vh; }
    
    .theme-blood .overlay[data-type="ready"] .inner { align-items:center; justify-content:flex-end; padding-right:12vw; }
    .theme-blood .overlay[data-type="light"] .inner { align-items:flex-end; padding-bottom:12vh; }
    .theme-blood .overlay[data-type="fill"] .inner { align-items:flex-start; padding-top:12vh; }
    .theme-blood .overlay[data-type="sniff"] .inner { align-items:center; justify-content:flex-start; padding-left:12vw; }
    .theme-blood .overlay[data-type="action"] .inner { align-items:center; }
    
    /* Video effects during events */
    .video-effect { transition: all 0.3s; }
    .theme-neon .video-effect.active { filter: hue-rotate(180deg) saturate(3); }
    .theme-inferno .video-effect.active { filter: saturate(2) contrast(1.5) brightness(1.2); animation: videoFlicker 0.15s infinite; }
    .theme-void .video-effect.active { filter: invert(0.3) hue-rotate(270deg) saturate(2); animation: videoPulse 1s infinite; }
    .theme-toxic .video-effect.active { filter: hue-rotate(90deg) saturate(3) contrast(1.3); animation: videoGlitch 0.2s infinite; }
    .theme-blood .video-effect.active { filter: sepia(0.5) saturate(2) hue-rotate(-20deg) brightness(0.9); animation: videoHeartbeat 1.2s infinite; }
    
    @keyframes videoFlicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes videoPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.08); } }
    @keyframes videoGlitch { 0%, 100% { transform: translate(0); } 25% { transform: translate(-5px, 5px); } 75% { transform: translate(5px, -5px); } }
    @keyframes videoHeartbeat { 0%, 100% { transform: scale(1); } 15% { transform: scale(1.05); } 30% { transform: scale(1); } }
    
    /* Theme-specific dramatic effects */
    .theme-neon { --pulseSpeed: 0.1s; }
    .theme-neon .overlay.show .inner { animation: neonPulse 0.15s infinite alternate; background: rgba(0,255,255,0.1); border: 2px solid #00ffff; box-shadow: 0 0 30px #00ffff, inset 0 0 20px #ff00ff; }
    .theme-neon .display-xxl { text-shadow: 0 0 10px #00ffff, 0 0 20px #ff00ff, 0 0 30px #00ffff; animation: textStrobe 0.1s infinite; }
    
    .theme-inferno .overlay.show .inner { background: linear-gradient(180deg, rgba(255,68,0,0.3), rgba(255,170,0,0.2)); border: 2px solid #ff4400; box-shadow: 0 0 40px #ff4400, inset 0 0 30px #ffaa00; }
    .theme-inferno .display-xxl { text-shadow: 0 0 20px #ff4400, 0 0 40px #ffaa00; animation: fireFlicker 0.2s infinite; }
    
    .theme-void .overlay.show .inner { background: radial-gradient(circle, rgba(102,0,255,0.3), rgba(0,0,0,0.8)); border: 2px solid #6600ff; box-shadow: 0 0 50px #6600ff, inset 0 0 40px #cc00ff; }
    .theme-void .display-xxl { text-shadow: 0 0 30px #6600ff, 0 0 50px #cc00ff; animation: voidPulse 2s infinite; }
    
    .theme-toxic .overlay.show .inner { background: rgba(0,255,0,0.15); border: 2px solid #00ff00; box-shadow: 0 0 35px #00ff00, inset 0 0 25px #88ff00; animation: toxicGlitch 0.3s infinite; }
    .theme-toxic .display-xxl { text-shadow: 0 0 15px #00ff00, 0 0 30px #88ff00, 2px 2px 0 #00ff00, -2px -2px 0 #88ff00; }
    
    .theme-blood .overlay.show .inner { background: radial-gradient(circle, rgba(255,0,0,0.4), rgba(34,0,0,0.6)); border: 2px solid #ff0000; box-shadow: 0 0 40px #ff0000, inset 0 0 30px #ff6666; }
    .theme-blood .display-xxl { text-shadow: 0 0 20px #ff0000, 0 0 40px #ff6666; animation: heartbeat 1.2s infinite; }
    
    /* Remove container boxes - make overlays full screen */
    .overlay .inner { background: transparent !important; border: none !important; box-shadow: none !important; padding: 0 !important; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; }
    .overlay.show { background: rgba(0,0,0,0.3); }
    
    /* Animations */
    @keyframes neonPulse { from {opacity: 0.7;} to {opacity: 1;} }
    @keyframes textStrobe { 0%, 100% {opacity: 1;} 50% {opacity: 0.6;} }
    @keyframes fireFlicker { 0%, 100% {opacity: 1; transform: scale(1);} 50% {opacity: 0.85; transform: scale(1.03);} }
    @keyframes voidPulse { 0%, 100% {transform: scale(1);} 50% {transform: scale(1.05);} }
    @keyframes toxicGlitch { 0%, 100% {transform: translate(0);} 33% {transform: translate(-2px, 2px);} 66% {transform: translate(2px, -2px);} }
    @keyframes heartbeat { 0%, 100% {transform: scale(1);} 10% {transform: scale(1.1);} 20% {transform: scale(1);} 30% {transform: scale(1.05);} 40% {transform: scale(1);} }
    
    /* Full-screen overlays for different stages */
    .stage-overlay { position: absolute; inset: 0; pointer-events: none; z-index: 10; transition: opacity 0.3s; opacity: 0; }
    .stage-overlay.active { opacity: 1; }
    
    /* Neon theme overlays - EXTREME */
    .theme-neon .stage-overlay.ready { background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,255,0.2) 2px, rgba(0,255,255,0.2) 4px); animation: scanlines 0.3s linear infinite; }
    .theme-neon .stage-overlay.light { background: radial-gradient(circle at center, rgba(255,0,255,0.7), rgba(0,255,255,0.5), transparent 60%); animation: neonPulse 0.1s infinite; }
    .theme-neon .stage-overlay.fill { background: linear-gradient(90deg, rgba(0,255,255,0.5), rgba(255,0,255,0.5), rgba(0,255,255,0.5)); background-size: 200% 100%; animation: gradientShift 0.5s linear infinite; }
    .theme-neon .stage-overlay.sniff { background: rgba(0,255,255,0.7); animation: strobeHard 0.05s infinite; mix-blend-mode:screen; }
    
    /* Inferno theme overlays - FIRE EVERYWHERE */
    .theme-inferno .stage-overlay.ready { background: radial-gradient(ellipse at bottom, rgba(255,68,0,0.5), rgba(255,170,0,0.3), transparent 70%); }
    .theme-inferno .stage-overlay.light { background: radial-gradient(circle at center, rgba(255,68,0,0.9), rgba(255,170,0,0.7), transparent 50%); animation: fireFlicker 0.1s infinite; mix-blend-mode:screen; }
    .theme-inferno .stage-overlay.fill { background: linear-gradient(0deg, rgba(255,68,0,0.8), rgba(255,170,0,0.6), rgba(255,255,0,0.4), transparent); animation: fireRise 1.5s ease-out infinite; }
    .theme-inferno .stage-overlay.sniff { background: radial-gradient(circle, rgba(255,68,0,0.8), rgba(255,170,0,0.6)); animation: fireFlicker 0.08s infinite; mix-blend-mode:screen; }
    
    /* Void theme overlays - DARK COSMIC */
    .theme-void .stage-overlay.ready { background: radial-gradient(circle at 50% 50%, transparent 20%, rgba(102,0,255,0.5) 100%); }
    .theme-void .stage-overlay.light { background: radial-gradient(circle at center, rgba(102,0,255,0.8), rgba(204,0,255,0.5), transparent 50%); animation: voidPulse 1s infinite; }
    .theme-void .stage-overlay.fill { background: radial-gradient(ellipse at center, rgba(204,0,255,0.6), rgba(102,0,255,0.4), transparent); animation: voidExpand 2s ease-in-out infinite; }
    .theme-void .stage-overlay.sniff { background: rgba(102,0,255,0.7); animation: voidPulse 0.3s infinite; mix-blend-mode:screen; }
    
    /* Toxic theme overlays - RADIOACTIVE */
    .theme-toxic .stage-overlay.ready { background: linear-gradient(180deg, transparent, rgba(0,255,0,0.4)); }
    .theme-toxic .stage-overlay.light { background: radial-gradient(circle, rgba(0,255,0,0.7), rgba(136,255,0,0.5), transparent 60%); animation: toxicGlitch 0.2s infinite; }
    .theme-toxic .stage-overlay.fill { background: repeating-linear-gradient(45deg, rgba(0,255,0,0.3), rgba(0,255,0,0.3) 10px, rgba(136,255,0,0.3) 10px, rgba(136,255,0,0.3) 20px); animation: toxicScroll 1s linear infinite; }
    .theme-toxic .stage-overlay.sniff { background: rgba(0,255,0,0.8); animation: toxicGlitch 0.05s infinite; mix-blend-mode:screen; }
    
    /* Blood theme overlays - INTENSE */
    .theme-blood .stage-overlay.ready { background: radial-gradient(circle at center, transparent 30%, rgba(255,0,0,0.4) 100%); }
    .theme-blood .stage-overlay.light { background: radial-gradient(circle at center, rgba(255,0,0,0.9), rgba(255,102,102,0.6), transparent 50%); animation: heartbeat 1s infinite; }
    .theme-blood .stage-overlay.fill { background: linear-gradient(0deg, rgba(255,0,0,0.7), rgba(255,102,102,0.5), transparent); animation: bloodDrip 2s ease-in infinite; }
    .theme-blood .stage-overlay.sniff { background: rgba(255,0,0,0.85); animation: bloodPulse 0.2s infinite; mix-blend-mode:screen; }
    
    @keyframes scanlines { from {background-position: 0 0;} to {background-position: 0 4px;} }
    @keyframes gradientShift { from {background-position: 0% 0;} to {background-position: 200% 0;} }
    @keyframes strobeHard { 0%, 100% {opacity: 1;} 50% {opacity: 0.3;} }
    @keyframes fireRise { from {transform: translateY(20%); opacity: 0;} to {transform: translateY(-100%); opacity: 1;} }
    @keyframes voidExpand { 0%, 100% {transform: scale(1);} 50% {transform: scale(1.3);} }
    @keyframes toxicScroll { from {background-position: 0 0;} to {background-position: 40px 40px;} }
    @keyframes bloodDrip { from {transform: translateY(-20%);} to {transform: translateY(0%);} }
    @keyframes bloodPulse { 0%, 100% {opacity: 0.8;} 50% {opacity: 1;} }
    /* FX */
    .fx-strobe{animation: strobe 95ms steps(2, jump-none) infinite}
    .fx-chroma{filter: drop-shadow(2px 0 0 rgba(255,0,120,.5)) drop-shadow(-2px 0 0 rgba(0,200,255,.5))}
    .fx-shake{animation: shake .35s cubic-bezier(.36,.07,.19,.97) both}
    @keyframes strobe{from{opacity:.3} to{opacity:1}}
    @keyframes shake{10%,90%{transform:translate3d(-1px,0,0)}20%,80%{transform:translate3d(2px,0,0)}30%,50%,70%{transform:translate3d(-4px,0,0)}40%,60%{transform:translate3d(4px,0,0)}

    /* --- Grid Choice Styles --- */
    .grid-choice-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,.85);
      z-index: 200;
      display: none; /* Show with a class */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      gap: 1rem;
      pointer-events: none;
    }
    .grid-choice-overlay.show { display: flex; pointer-events: auto; }
    .grid-choice-title { font-size: clamp(1.5rem, 4vw, 2.5rem); font-weight: 700; color: white; text-shadow: 0 1px 3px #000; }
    .grid-choice-timer { position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; font-weight: 800; color: #fff; background: #c00; padding: .2rem .5rem; border-radius: .4rem; }
    .grid-choice-grid { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: .5rem; width: 80%; height: 70%; max-width: 800px; }
    .grid-choice-item { position: relative; cursor: pointer; border: 2px solid #555; border-radius: .5rem; overflow: hidden; transition: border-color .2s; }
    .grid-choice-item:hover { border-color: #fff; transform: scale(1.03); }
    .grid-choice-item video { width: 100%; height: 100%; object-fit: cover; }
    .grid-choice-item .item-label { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,.7); color: white; padding: .2rem .4rem; font-size: .8rem; text-align: center; }
    .grid-choice-item.correct { border-color: #0F0; box-shadow: 0 0 20px #0F0; }
    .grid-choice-item.wrong { border-color: #F00; box-shadow: 0 0 20px #F00; }

    /* --- Action Choice Styles --- */
    .action-choice-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,.85);
      z-index: 250;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      gap: 1rem;
      pointer-events: none;
    }
    .action-choice-overlay.show { display: flex; pointer-events: auto; }
    .action-choice-title { font-size: clamp(1.5rem, 4vw, 2.5rem); font-weight: 700; color: white; }
    .action-choice-timer { position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; font-weight: 800; color: #fff; background: #c00; padding: .2rem .5rem; border-radius: .4rem; }

    /* make choice timers more prominent */
    .grid-choice-timer, .action-choice-timer { font-size: clamp(1.2rem, 3vw, 2.4rem); padding:.25rem .6rem; background: rgba(192,0,0,0.95); box-shadow: 0 6px 18px rgba(0,0,0,.5); }
    .action-choice-list { display: flex; flex-direction: column; gap: .75rem; width: 80%; max-width: 600px; }
    .action-choice-item {
      background: #141b2b;
      color: var(--fg);
      border: 1px solid var(--panelBorder);
      padding: 1rem 1.2rem;
      border-radius: .6rem;
      cursor: pointer;
      font-weight: 600;
      font-size: 1.2rem;
      transition: transform .1s ease, background .1s ease;
    }
    .action-choice-item:hover { background: #1a2030; transform: scale(1.03); }



    /* --- End Cycle Dialog --- */
    #endCycleDialog { z-index: 500; }
    #endCycleDialog .inner { background:rgba(0,0,0,.8); }
    #endCycleDialog .end-buttons { margin-top: 1rem; display:flex; gap:1rem; pointer-events:auto; }
    #endCycleDialog .end-buttons button { font-size:1.5rem; padding:.5rem 2rem; color:white; border:none; border-radius:.5rem; cursor:pointer; }
    #endCycleDialog .btn-end-fail { background: #C00; }
    #endCycleDialog .btn-end-complete { background: #0A0; }

  video, .quadrant {will-change: transform; transform: translateZ(0);} 
/* --- PATCH: hidden plan, enhanced tint overlay --- */
.emojisPlan{ display:none !important; }
.phaseTint{ mix-blend-mode:overlay; }
.clip-option:hover { border-color:rgba(255,255,255,.5) !important; }
.clip-option.selected { border-color:#44ff44 !important; box-shadow:0 0 20px #44ff44; }

/* --- Reduced-intensity & performance-friendly overrides --- */
.nextTimer{position:absolute; left:1rem; bottom:1.25rem; top:auto; right:auto; min-width:0; font-size:clamp(1.8rem, 4vw, 4rem); padding:0; background:transparent; box-shadow:none; border-radius:0; display:flex; align-items:center; justify-content:flex-start; color:rgba(255,255,255,.95); opacity:.88; pointer-events:none; z-index:60;}
.nextTimer .bar{position:absolute; left:0; right:0; bottom:-6px; height:4px; background:var(--themeAccent, #8ab4ff); opacity:.6; border-radius:2px;}
.phaseTint.show{opacity:.12 !important}
.overlay.show{background:rgba(0,0,0,0.12) !important}
.quadrant.bulge{transform:scale(1.03) !important; box-shadow:none !important}
.video-effect.active{filter:none !important; animation:none !important; transition:transform .18s ease, opacity .12s ease;}
.display-xxl, .display-lg{ text-shadow: none; }
.emojisPlan{display:none !important}
.theme-neon .display-xxl, .theme-inferno .display-xxl, .theme-void .display-xxl, .theme-toxic .display-xxl, .theme-blood .display-xxl { animation:none !important; }

</style>
</head>
<body>
  <div class="dock">
    <label for="folderPicker">üé¨ Pick videos</label>
    <input id="folderPicker" type="file" webkitdirectory directory multiple accept="video/*" />
    <button id="btnStart">‚ñ∂Ô∏é Start</button>
    <button id="btnStop">‚èπ Stop</button> <button id="btnFury" style="display:none">Fury Off</button>
    <button id="btnFSAll" title="Fullscreen app">‚õ∂</button>
    <span class="spacer"></span>
    <button id="btnMuteAll" title="Mute/Unmute all">üîá</button>
    <span id="status" class="hint">Load ‚â•4 vids, Start, then pick theme/video. Complete 9 tasks. Stay synced.</span>
  </div>

  <div class="stage">
<div class="quadrant" id="q1">
  <div class="selectBadge"></div>
  <div class="corners"></div>
  <div class="phaseTint"></div>
  <div class="qcontrols">
    <button class="shuffleOffset" title="Shuffle clip offset">üé≤</button>
    <button class="shuffleVideo" title="Swap video">‚áÑ</button>
    <button class="btnFS" title="Fullscreen this quad">‚õ∂</button>
    <button class="btnSound" title="Play this quad's audio">üîà</button>
  </div>
  <video playsinline webkit-playsinline muted preload="metadata" class="quad-video" playsinline preload="metadata" muted style="will-change:transform;transform:translateZ(0);"></video>
  <div class="stage-overlay ready"></div>
  <div class="stage-overlay light"></div>
  <div class="stage-overlay fill"></div>
  <div class="stage-overlay sniff"></div>
  <div class="overlay chooseTint">
    <div class="chooseTitle">CHOOSE THEME & VIDEO</div>
    <div class="theme-name" style="font-size:1.5rem; margin:.5rem 0; font-weight:700;"></div>
    <button class="btn-change-theme" style="margin-bottom:1rem;">Change Theme</button>
    <div class="clip-selection-grid" style="display:grid; grid-template-columns:1fr 1fr; gap:.5rem; width:80%; max-width:600px; margin-bottom:1rem;">
      <div class="clip-option" data-idx="0" style="cursor:pointer; border:3px solid transparent; border-radius:.5rem; overflow:hidden; transition:border-color .2s;">
        <video playsinline webkit-playsinline muted preload="metadata" loop style="width:100%; height:100%; object-fit:cover;"></video>
        <div class="clip-label" style="background:rgba(0,0,0,.8); color:white; padding:.3rem; text-align:center; font-size:.9rem;"></div>
      </div>
      <div class="clip-option" data-idx="1" style="cursor:pointer; border:3px solid transparent; border-radius:.5rem; overflow:hidden; transition:border-color .2s;">
        <video playsinline webkit-playsinline muted preload="metadata" loop style="width:100%; height:100%; object-fit:cover;"></video>
        <div class="clip-label" style="background:rgba(0,0,0,.8); color:white; padding:.3rem; text-align:center; font-size:.9rem;"></div>
      </div>
      <div class="clip-option" data-idx="2" style="cursor:pointer; border:3px solid transparent; border-radius:.5rem; overflow:hidden; transition:border-color .2s;">
        <video playsinline webkit-playsinline muted preload="metadata" loop style="width:100%; height:100%; object-fit:cover;"></video>
        <div class="clip-label" style="background:rgba(0,0,0,.8); color:white; padding:.3rem; text-align:center; font-size:.9rem;"></div>
      </div>
      <div class="clip-option" data-idx="3" style="cursor:pointer; border:3px solid transparent; border-radius:.5rem; overflow:hidden; transition:border-color .2s;">
        <video playsinline webkit-playsinline muted preload="metadata" loop style="width:100%; height:100%; object-fit:cover;"></video>
        <div class="clip-label" style="background:rgba(0,0,0,.8); color:white; padding:.3rem; text-align:center; font-size:.9rem;"></div>
      </div>
    </div>
    <button class="btn-player-start" style="pointer-events:auto; cursor:pointer; font-size:2rem; padding:1rem 3rem; border-radius:.8rem; background:#44ff44; color:black; border:3px solid white; font-weight:900;">START</button>
    <div class="emojisPlan"></div>
  </div>
  <div class="overlay cue" data-type="pre"><div class="inner"><div class="display-lg">NEXT</div></div></div>
  <div class="overlay cue" data-type="ready"><div class="inner"><div class="display-xxl">GET&nbsp;READY</div></div></div>
  <div class="overlay cue" data-type="light"><div class="inner"><div class="display-xxl">LIGHT</div></div></div>
  <div class="overlay cue" data-type="fill"><div class="inner"><div class="display-xxl">FILL&nbsp;THE&nbsp;BAG</div></div></div>
  <div class="overlay cue" data-type="sniff"><div class="inner"><div class="display-xxl">SNIFF</div></div></div>
  <div class="overlay cue" data-type="mask"><div class="inner"><div class="display-xxl">MASK</div></div></div>
  <div class="overlay cue" data-type="action"><div class="inner">
    <div class="display-xxl">ACTION</div>
    <div class="display-lg">ACTION</div>
    <button class="btn-action-complete" style="pointer-events:auto; cursor:pointer; font-size:1.5rem; padding:.5rem 1rem; margin-top:1rem; border-radius:.5rem; background:rgba(46,204,113,.9); color:white; border:1px solid white;">COMPLETE</button>
  </div></div>
  <div class="overlay cue" data-type="chill"><div class="inner"><div class="display-xxl">CHILL</div></div></div>
  <div class="overlay cue" data-type="inhale"><div class="inner"><div class="display-xxl">INHALE</div></div></div>
  <div class="overlay cue" data-type="hold"><div class="inner"><div class="display-xxl">HOLD</div></div></div>
  <div class="overlay cue" data-type="exhale"><div class="inner"><div class="display-xxl">EXHALE</div></div></div>
  <div class="nextTimer"><div class="bar"></div></div>
  <div class="tally"></div>
  <div class="task-buttons">
    <button class="btn-task-fail">‚úó</button>
    <button class="btn-task-complete">‚úì</button>
  </div>
  <div class="manual-controls">
    <button class="btn-manual-skip">SKIP</button>
    <button class="btn-manual-shuffle">SHUFFLE VID</button>
  </div>
  <div class="grid-choice-overlay">
    <div class="grid-choice-timer">20</div>
    <div class="grid-choice-title">CHOOSE NEW VIDEO</div>
    <div class="grid-choice-grid">
      <div class="grid-choice-item" data-idx="0"><video playsinline webkit-playsinline muted preload="metadata" playsinline preload="metadata" muted style="will-change:transform;transform:translateZ(0);"></video> Tina </div>
      <div class="grid-choice-item" data-idx="1"><video playsinline webkit-playsinline muted preload="metadata" playsinline preload="metadata" muted style="will-change:transform;transform:translateZ(0);"></video> Dick </div>
      <div class="grid-choice-item" data-idx="2"><video playsinline webkit-playsinline muted preload="metadata" playsinline preload="metadata" muted style="will-change:transform;transform:translateZ(0);"></video> Poppi </div>
      <div class="grid-choice-item" data-idx="3"><video playsinline webkit-playsinline muted preload="metadata" playsinline preload="metadata" muted style="will-change:transform;transform:translateZ(0);"></video> Gina </div>
    </div>
  </div>
  <div class="action-choice-overlay">
    <div class="action-choice-timer">20</div>
    <div class="action-choice-title">CHOOSE NEXT ACTION</div>
    <div class="action-choice-list"></div>
  </div>
</div>


<div class="quadrant" id="q2">
  <div class="selectBadge"></div>
  <div class="corners"></div>
  <div class="phaseTint"></div>
  <div class="qcontrols">
    <button class="shuffleOffset" title="Shuffle clip offset">üé≤</button>
    <button class="shuffleVideo" title="Swap video">‚áÑ</button>
    <button class="btnFS" title="Fullscreen this quad">‚õ∂</button>
    <button class="btnSound" title="Play this quad's audio">üîà</button>
  </div>
  <video playsinline webkit-playsinline muted preload="metadata" class="quad-video" playsinline preload="metadata" muted style="will-change:transform;transform:translateZ(0);"></video>
  <div class="stage-overlay ready"></div>
  <div class="stage-overlay light"></div>
  <div class="stage-overlay fill"></div>
  <div class="stage-overlay sniff"></div>
  <div class="overlay chooseTint">
    <div class="chooseTitle">CHOOSE THEME & VIDEO</div>
    <div class="theme-name" style="font-size:1.5rem; margin:.5rem 0; font-weight:700;"></div>
    <button class="btn-change-theme" style="margin-bottom:1rem;">Change Theme</button>
    <div class="clip-selection-grid" style="display:grid; grid-template-columns:1fr 1fr; gap:.5rem; width:80%; max-width:600px; margin-bottom:1rem;">
      <div class="clip-option" data-idx="0" style="cursor:pointer; border:3px solid transparent; border-radius:.5rem; overflow:hidden; transition:border-color .2s;">
        <video playsinline webkit-playsinline muted preload="metadata" loop style="width:100%; height:100%; object-fit:cover;"></video>
        <div class="clip-label" style="background:rgba(0,0,0,.8); color:white; padding:.3rem; text-align:center; font-size:.9rem;"></div>
      </div>
      <div class="clip-option" data-idx="1" style="cursor:pointer; border:3px solid transparent; border-radius:.5rem; overflow:hidden; transition:border-color .2s;">
        <video playsinline webkit-playsinline muted preload="metadata" loop style="width:100%; height:100%; object-fit:cover;"></video>
        <div class="clip-label" style="background:rgba(0,0,0,.8); color:white; padding:.3rem; text-align:center; font-size:.9rem;"></div>
      </div>
      <div class="clip-option" data-idx="2" style="cursor:pointer; border:3px solid transparent; border-radius:.5rem; overflow:hidden; transition:border-color .2s;">
        <video playsinline webkit-playsinline muted preload="metadata" loop style="width:100%; height:100%; object-fit:cover;"></video>
        <div class="clip-label" style="background:rgba(0,0,0,.8); color:white; padding:.3rem; text-align:center; font-size:.9rem;"></div>
      </div>
      <div class="clip-option" data-idx="3" style="cursor:pointer; border:3px solid transparent; border-radius:.5rem; overflow:hidden; transition:border-color .2s;">
        <video playsinline webkit-playsinline muted preload="metadata" loop style="width:100%; height:100%; object-fit:cover;"></video>
        <div class="clip-label" style="background:rgba(0,0,0,.8); color:white; padding:.3rem; text-align:center; font-size:.9rem;"></div>
      </div>
    </div>
    <button class="btn-player-start" style="pointer-events:auto; cursor:pointer; font-size:2rem; padding:1rem 3rem; border-radius:.8rem; background:#44ff44; color:black; border:3px solid white; font-weight:900;">START</button>
    <div class="emojisPlan"></div>
  </div>
  <div class="overlay cue" data-type="pre"><div class="inner"><div class="display-lg">NEXT</div></div></div>
  <div class="overlay cue" data-type="ready"><div class="inner"><div class="display-xxl">GET&nbsp;READY</div></div></div>
  <div class="overlay cue" data-type="light"><div class="inner"><div class="display-xxl">LIGHT</div></div></div>
  <div class="overlay cue" data-type="fill"><div class="inner"><div class="display-xxl">FILL&nbsp;THE&nbsp;BAG</div></div></div>
  <div class="overlay cue" data-type="sniff"><div class="inner"><div class="display-xxl">SNIFF</div></div></div>
  <div class="overlay cue" data-type="mask"><div class="inner"><div class="display-xxl">MASK</div></div></div>
  <div class="overlay cue" data-type="action"><div class="inner">
    <div class="display-xxl">ACTION</div>
    <div class="display-lg">ACTION</div>
  </div></div>
  <div class="overlay cue" data-type="chill"><div class="inner"><div class="display-xxl">CHILL</div></div></div>
  <div class="overlay cue" data-type="inhale"><div class="inner"><div class="display-xxl">INHALE</div></div></div>
  <div class="overlay cue" data-type="hold"><div class="inner"><div class="display-xxl">HOLD</div></div></div>
  <div class="overlay cue" data-type="exhale"><div class="inner"><div class="display-xxl">EXHALE</div></div></div>
  <div class="nextTimer"><div class="bar"></div></div>
  <div class="tally"></div>
  <div class="task-buttons">
    <button class="btn-task-fail">‚úó</button>
    <button class="btn-task-complete">‚úì</button>
  </div>
  <div class="manual-controls">
    <button class="btn-manual-skip">SKIP</button>
    <button class="btn-manual-shuffle">SHUFFLE VID</button>
  </div>
  <div class="grid-choice-overlay">
    <div class="grid-choice-timer">20</div>
    <div class="grid-choice-title">CHOOSE NEW VIDEO</div>
    <div class="grid-choice-grid">
      <div class="grid-choice-item" data-idx="0"><video playsinline webkit-playsinline muted preload="metadata" playsinline preload="metadata" muted style="will-change:transform;transform:translateZ(0);"></video> Tina </div>
      <div class="grid-choice-item" data-idx="1"><video playsinline webkit-playsinline muted preload="metadata" playsinline preload="metadata" muted style="will-change:transform;transform:translateZ(0);"></video> Dick </div>
      <div class="grid-choice-item" data-idx="2"><video playsinline webkit-playsinline muted preload="metadata" playsinline preload="metadata" muted style="will-change:transform;transform:translateZ(0);"></video> Poppi </div>
      <div class="grid-choice-item" data-idx="3"><video playsinline webkit-playsinline muted preload="metadata" playsinline preload="metadata" muted style="will-change:transform;transform:translateZ(0);"></video> Gina </div>
    </div>
  </div>
  <div class="action-choice-overlay">
    <div class="action-choice-timer">20</div>
    <div class="action-choice-title">CHOOSE NEXT ACTION</div>
    <div class="action-choice-list"></div>
  </div>
</div>
</div>


  <script>
  (()=> {
    // Ferocity params
    
const FURY = {
  on:false,
  jitterAmp:1,
  takeoverMin:8000,
  takeoverMax:16000,
  pulseScale:1.06,
  tintAlpha:.22,
  cutsBoost:1,
  gapScale:1,
  minGap:20000,
  precueScale:1
};

    // 5 Dramatic Visual Themes
    const VIBES = [
      {key:'graffiti', palette:{base:'#00ffff', accent:'#ff00ff', dark:'#0a0a0a'}, intensity:1.0, clipCutsPerTask:5, gap:[15,35], sniff:8000, precue:600, overlay:'cyan-magenta-strobe', pulseEffect:'strobe'},
      {key:'danger', palette:{base:'#ff4400', accent:'#ffaa00', dark:'#330000'}, intensity:0.95, clipCutsPerTask:4, gap:[18,40], sniff:9000, precue:800, overlay:'fire-gradient', pulseEffect:'flicker'},
      {key:'industrial', palette:{base:'#6600ff', accent:'#cc00ff', dark:'#000000'}, intensity:0.85, clipCutsPerTask:3, gap:[20,45], sniff:10000, precue:900, overlay:'purple-smoke', pulseEffect:'pulse'},
      {key:'modern', palette:{base:'#00ff00', accent:'#88ff00', dark:'#001100'}, intensity:0.9, clipCutsPerTask:4, gap:[17,38], sniff:8500, precue:700, overlay:'green-haze', pulseEffect:'glitch'},
      {key:'neon', palette:{base:'#ff0000', accent:'#ff6666', dark:'#220000'}, intensity:1.0, clipCutsPerTask:6, gap:[15,35], sniff:7500, precue:500, overlay:'red-vignette', pulseEffect:'heartbeat'}
    ];
    const ACTIONS = [
      {label:"Stand up and stretch", seconds:10},
      {label:"Copy the main actor's pose", seconds:5},
      {label:"Drink something", seconds:10},
      {label:"Balance on one foot", seconds:10},
      {label:"Put your feet above your head", seconds:10},
      {label:"Touch something wooden", seconds:5},
      {label:"CHANGE oufit", seconds:20},
      {label:"Mirror the actor's facial expression", seconds:5},
      {label:"CHANGE the song", seconds:10},
      {label:"CHANGE seat", seconds:10},
      {label:"PUT 3 useful things on the table", seconds:10},
      {label:"Gather 3 lighers", seconds:10},
      {label:"Say 6 dirty words", seconds:7},
      {label:"Make a sound effect for the scene", seconds:7}
    ];
    const randInt = (min,max)=> Math.floor(Math.random()*(max-min+1))+min;
    const CHOICE_MENU = [
      { label: 'PUFF', build: () => ({ type:'puff' }) },
      { label: 'SNIFF', build: () => ({ type:'sniff' }) },
      { label: 'MASK', build: () => ({ type:'mask', duration: randInt(MASK_WINDOW[0], MASK_WINDOW[1]) }) },
      { label: 'TASK', build: () => ({ type:'action', action: randomlySelectItem(ACTIONS) }) },
      { label: 'CHILL', build: () => ({ type:'chill', duration: randInt(CHILL_WINDOW[0], CHILL_WINDOW[1]) }) }
    ];
    const MASK_READY_MS = 5000;
    const MASK_WINDOW = [10000, 30000];
    const CHILL_WINDOW = [10000, 20000];
    const DUR = { ready:5000, light:12000, fill:12000, inhale:5000, hold:4000, exhale:5000 };
    const PUFF_TOTAL = DUR.ready + DUR.light + DUR.fill + 5*(DUR.inhale + DUR.hold + DUR.exhale);
    // Reduce emoji usage for subtlety/per-theme consistency
    const EMOJI = {
      ready:'', light:'', fill:'', inhale:'', hold:'', exhale:'', sniff:'', mask:'', action:'', puff:'',
      chill:''
    };

    // Event-specific flashy colors (used during events regardless of theme)
    const EVENT_COLORS = {
      ready: '#ffffff',
      light: '#ff4500',    // fiery
      sniff: '#00fff0',    // neon
      fill: '#cfd8ff',     // cloudy (puff)
      inhale: '#88ff66',   // greenish
      hold: '#ffdd55',     // yellowish
      exhale: '#66ccff',   // bluish
      action: '#ffd1ff',
      mask:'#6c99ff',
      chill:'#8ad4ff'
    };

    const makeQuad = (root) => ({
      el: root,
      video: root.querySelector('video'),
      overlays: Object.fromEntries(Array.from(root.querySelectorAll('.overlay.cue')).map(o=>[o.dataset.type,o])),
      stageOverlays: {
        ready: root.querySelector('.stage-overlay.ready'),
        light: root.querySelector('.stage-overlay.light'),
        fill: root.querySelector('.stage-overlay.fill'),
        sniff: root.querySelector('.stage-overlay.sniff')
      },
      chooseTint: root.querySelector('.chooseTint'),
      nextTimer: root.querySelector('.nextTimer'),
      nextBar: root.querySelector('.nextTimer .bar'),
      selectBadge: root.querySelector('.selectBadge'),
      tally: root.querySelector('.tally'),
      phaseTint: root.querySelector('.phaseTint'),
      taskButtons: root.querySelector('.task-buttons'),
      btnTaskComplete: root.querySelector('.btn-task-complete'),
      btnTaskFail: root.querySelector('.btn-task-fail'),
      btnManualSkip: root.querySelector('.btn-manual-skip'),
      btnManualShuffle: root.querySelector('.btn-manual-shuffle'),
      queue: [], busy:false, ticker:null, nextTaskTimer: null, baseClip:null, vibe:null, label:'', chosen:true, completed: [], currentTask: null, taskButtonTimeout: null, videoErrorCount: 0
    });
    const quads = Array.from({length:2}).map((_,i)=> makeQuad(document.getElementById('q'+(i+1))));

    const folderPicker = document.getElementById('folderPicker');
    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const btnFSAll = document.getElementById('btnFSAll');
    const btnFury = document.getElementById('btnFury');
    const btnMuteAll = document.getElementById('btnMuteAll');
    const status = document.getElementById('status');
    const stage = document.querySelector('.stage');
    let videos = [];
    let createdObjectURLs = [];
    let globalRafId = null;
    const activeIntervals = new Set();

    function startGlobalClock(){
      if (globalRafId) return;
      const tick = ()=>{
        const now = performance.now();
        quads.forEach(q=>{
          if (q.nextTargetTime){
            const task = q.queue && q.queue[0];
            const msLeft = Math.max(0, q.nextTargetTime - now);
            if (task){
              const label = task.type.toUpperCase();
              // Fix timer flicker at 0 by using a small threshold
              if (msLeft <= 20){
                q.nextTimer.textContent = `${label} in 0s`;
              } else {
                const secs = Math.ceil(msLeft/1000);
                q.nextTimer.textContent = `${label} in ${secs}s`;
              }
              const pct = Math.min(100, Math.max(0, ((q.nextGapMs - msLeft) / (q.nextGapMs || 1)) * 100));
              if (q.nextBar) q.nextBar.style.width = pct.toFixed(1) + '%';
            } else {
              q.nextTimer.textContent = 'Tasks complete!';
              if (q.nextBar) q.nextBar.style.width = '0%';
            }
          }
        });
        globalRafId = requestAnimationFrame(tick);
      };
      globalRafId = requestAnimationFrame(tick);
    }
    function stopGlobalClock(){ if (globalRafId){ cancelAnimationFrame(globalRafId); globalRafId = null; } }
    let cycleAbort = null;
    let cycleEnded = false;
    let stopGridChoice = null;
    let stopActionChoice = null;
    // Global lock to prevent overlapping event executions across quads
    let globalEventLock = false;

    const randomlySelectItem = (array)=> array[Math.floor(Math.random()*array.length)];
    const waitForDuration = (milliseconds)=> new Promise(resolve=>setTimeout(resolve,milliseconds));
    const convertToTitleCase = (string)=> (string||'').replace(/\.[^/.]+$/, '').replace(/[_\-]+/g,' ').trim().split(/\s+/).slice(0,3).map(word=>word[0]?word[0].toUpperCase()+word.slice(1):'').join(' ');

    function randomMidStart(clip){
      const duration = Number.isFinite(clip.duration) && clip.duration>10 ? clip.duration : 7200;
      const padStart = 0.5, padEnd = 3.0;
      const min = padStart, max = Math.max(min+1, duration - padEnd);
      return min + Math.random()*(max - min);
    }
    async function setClip(quadrantIndex, clip, start){
      const quadrant = quads[quadrantIndex]; const video = quadrant.video;
      
      // Video error handling
      const handleVideoError = () => {
        quadrant.videoErrorCount++;
        console.warn(`Video error on quad ${quadrantIndex}, count: ${quadrant.videoErrorCount}`);
        if (quadrant.videoErrorCount > 3) {
          // Try different video
          const otherClips = videos.filter(c => c.url !== clip.url);
          if (otherClips.length > 0) {
            const newClip = randomlySelectItem(otherClips);
            quadrant.baseClip = newClip;
            quadrant.videoErrorCount = 0;
            setClip(quadrantIndex, newClip, randomMidStart(newClip));
          }
        }
      };
      
      // Use event listeners instead of polling for better performance
      const handlePause = () => {
        if (!cycleAbort && quadrant.chosen && !video.ended) {
          video.play().catch(() => {});
        }
      };
      
      const handleEnded = () => {
        if (!cycleAbort && quadrant.chosen) {
          video.currentTime = randomMidStart(clip);
          video.play().catch(() => {});
        }
      };
      
      video.addEventListener('pause', handlePause);
      video.addEventListener('ended', handleEnded);
      
      // Store cleanup function
      quadrant.cleanupVideoMonitor = () => {
        video.removeEventListener('pause', handlePause);
        video.removeEventListener('ended', handleEnded);
      };
      
      video.onerror = handleVideoError;
      
      if (!video.src || video.src !== clip.url){ video.src = clip.url; }
      if (video.readyState < 1){ await new Promise(r=> video.addEventListener('loadedmetadata', ()=>r(), {once:true})); }
      const seekOnce = (time) => new Promise((resolve)=>{
        const duration = Number.isFinite(video.duration) && video.duration>0 ? video.duration : (Number.isFinite(clip.duration)?clip.duration:0);
        const padStart = 0.25, padEnd = 3.0;
        const maxT = duration>0 ? Math.max(padStart, duration - padEnd) : time;
        const safeT = Math.min(Math.max(padStart, time), maxT);
        const cleanup=()=>{video.removeEventListener('seeked', onSeeked); video.removeEventListener('error', onErr); video.removeEventListener('stalled', onErr);};
        const onSeeked=()=>{cleanup(); resolve(true)};
        const onErr=()=>{cleanup(); handleVideoError(); resolve(false)};
        video.addEventListener('seeked', onSeeked, {once:true});
        video.addEventListener('error', onErr, {once:true});
        video.addEventListener('stalled', onErr, {once:true});
        try{ video.currentTime = safeT; }catch(e){ cleanup(); resolve(false); return; }
        const p=video.play(); if(p&&p.catch)p.catch(()=>{});
      });
      let ok = await seekOnce(start);
      if (!ok) ok = await seekOnce(start*0.9);
      if (!ok) ok = await seekOnce(0.5);
      if (ok) quadrant.videoErrorCount = Math.max(0, quadrant.videoErrorCount - 1);
    }

    function setPhaseColor(qi, color){
      const node = quads[qi].el;
      node.style.setProperty('--pulseColor', color);
    }
    function hideAll(qi){
      const overlays = quads[qi].overlays;
      for(const k in overlays){ overlays[k].classList.remove('show'); }
      quads[qi].el.classList.remove('bulge','fx-shake');
      quads[qi].phaseTint.classList.remove('show');
      // clear any running countdown interval for this quad
      try{
        const q = quads[qi];
        if (q.countdownInterval){ clearInterval(q.countdownInterval); try{ activeIntervals.delete(q.countdownInterval); }catch(e){} q.countdownInterval = null; }
      }catch(e){}
    }
    
function pulseQuad(qi, color){
  setPhaseColor(qi, color);
  quads[qi].el.classList.add('bulge');
  // fury shake removed
  quads[qi].phaseTint.style.background = color;
  quads[qi].phaseTint.style.opacity = '0.22';
  quads[qi].phaseTint.classList.add('show');
}

    async function showCue(qi, type, color, ms /* icon intentionally ignored for subtler UI */){
      const el = quads[qi].overlays[type];
      if (!el || cycleAbort) return;
      hideAll(qi); pulseQuad(qi, color);
      const inner = el.querySelector('.inner');
      // Smaller title during events and a live countdown showing remaining ms
      const label = (type||'').toUpperCase();
      inner.innerHTML = '<div class="display-xxl" style="font-size:clamp(3rem,8vw,8rem);line-height:1">'+label+'</div>' +
                        '<div class="display-lg" style="font-size:clamp(1rem,2.2vw,2rem);opacity:.95;margin-top:.35rem">'+label+'</div>' +
                        '<div class="cue-countdown" style="font-size:1.1rem;opacity:.95;margin-top:.35rem">'+Math.ceil(ms/1000)+'s</div>';

      // Add a lightweight video effect during event
      quads[qi].video.classList.add('video-effect', 'active');

      el.classList.add('show');

      // start countdown interval
      try{ if (quads[qi].countdownInterval){ clearInterval(quads[qi].countdownInterval); } }catch(e){}
      const end = performance.now() + ms;
      const update = ()=>{
        const left = Math.max(0, Math.ceil((end - performance.now())/1000));
        const node = el.querySelector('.cue-countdown');
        if (node) node.textContent = left + 's';
        if (left <= 0){ /* will be cleared below */ }
      };
      update();
      const id = setInterval(()=>{
        update();
      }, 250);
      quads[qi].countdownInterval = id; activeIntervals.add(id);

      // ensure phase tint uses given color and a stronger opacity for event
      quads[qi].phaseTint.style.background = color;
      quads[qi].phaseTint.style.opacity = '0.28';

      await waitForDuration(ms);

      // cleanup countdown
      try{ clearInterval(quads[qi].countdownInterval); activeIntervals.delete(quads[qi].countdownInterval);}catch(e){}
      quads[qi].countdownInterval = null;

      el.classList.remove('show');

      // Remove video effect
      quads[qi].video.classList.remove('active');

      hideAll(qi);
    }
    async function preCue(qi, text, color, ms){
      const el = quads[qi].overlays['pre']; const inner = el.querySelector('.inner');
      hideAll(qi); pulseQuad(qi, color);
      // Use the provided text (subtle) rather than a large emoji
      inner.innerHTML = '<div class="display-xxl">'+text+'</div>';
      el.classList.add('show');
      await waitForDuration(ms);
      el.classList.remove('show');
      hideAll(qi);
    }

    
function addTally(qi, type, success = true){
  const q = quads[qi];
  const emoji = EMOJI[type] || '‚Ä¢';
  const mark = success ? '‚úì' : '‚úó';
  q.completed.push({type, success, emoji});
  
  // Build emoji log - show most recent 20 items
  const recent = q.completed.slice(-20);
  const tallyText = recent.map(item => `${item.emoji}${item.success ? '' : '‚úó'}`).join(' ');
  q.tally.textContent = tallyText || 'Ready...';
}


    
async function runPuff(qi){
  const q = quads[qi]; if (!q.chosen || cycleAbort) return {success: false};
  const pal = q.vibe.palette; const clip = q.baseClip;

  await preCue(qi, 'PUFF', pal.base, Math.max(400, (q.vibe.precue||800)));

  await setClip(qi, clip, randomMidStart(clip));
  
  // Activate ready overlay (use event color map)
  if (q.stageOverlays.ready) q.stageOverlays.ready.classList.add('active');
  await showCue(qi,'ready', EVENT_COLORS.ready, DUR.ready);
  if (q.stageOverlays.ready) q.stageOverlays.ready.classList.remove('active');
  if (cycleAbort) return {success: false};

  // Activate light overlay (fiery)
  if (q.stageOverlays.light) q.stageOverlays.light.classList.add('active');
  await showCue(qi,'light', EVENT_COLORS.light, DUR.light);
  if (q.stageOverlays.light) q.stageOverlays.light.classList.remove('active');
  if (cycleAbort) return {success: false};

  // Activate fill overlay (cloudy/puff)
  if (q.stageOverlays.fill) q.stageOverlays.fill.classList.add('active');
  await showCue(qi,'fill', EVENT_COLORS.fill, DUR.fill);
  if (q.stageOverlays.fill) q.stageOverlays.fill.classList.remove('active');
  if (cycleAbort) return {success: false};

  await setClip(qi, clip, randomMidStart(clip));
  for(let i=0;i<5;i++){
    if (cycleAbort) return {success: false};
    await showCue(qi,'inhale', EVENT_COLORS.inhale, DUR.inhale);
    if (cycleAbort) return {success: false};

    await showCue(qi,'hold', EVENT_COLORS.hold, DUR.hold);
    if (cycleAbort) return {success: false};

    await showCue(qi,'exhale', EVENT_COLORS.exhale, DUR.exhale);
  }
  
  // Show completion buttons
  const result = await showTaskButtons(qi);
  return result;
}

    
async function runSniff(qi){
  const q = quads[qi]; if (!q.chosen || cycleAbort) return {success: false};
  const pal = q.vibe.palette; const clip = q.baseClip;

  await preCue(qi, 'SNIFF', pal.base, Math.max(400, (q.vibe.precue||800)));

  await setClip(qi, clip, randomMidStart(clip));

  // Activate sniff overlay (neon)
  if (q.stageOverlays.sniff) q.stageOverlays.sniff.classList.add('active');
  
  const endAt = performance.now()+(q.vibe.sniff||10000);
  while(performance.now()<endAt && q.chosen && !cycleAbort){
    await setClip(qi, clip, randomMidStart(clip));
    await showCue(qi,'sniff', EVENT_COLORS.sniff, 120);
    await waitForDuration(50);
  }
  
  // Deactivate sniff overlay
  if (q.stageOverlays.sniff) q.stageOverlays.sniff.classList.remove('active');
  
  if (cycleAbort) return {success: false};
  const result = await showTaskButtons(qi);
  return result;
}


    
async function runMask(qi, task){
      const q = quads[qi]; if (!q.chosen || cycleAbort) return {success:false};
      const duration = task?.duration || randInt(MASK_WINDOW[0], MASK_WINDOW[1]);
      await preCue(qi, 'GET READY FOR THE MASK', q.vibe.palette.base, MASK_READY_MS);
      await setClip(qi, q.baseClip, randomMidStart(q.baseClip));
      await showCue(qi, 'mask', EVENT_COLORS.mask, duration);
      return {success:true};
    }
    async function runChill(qi, task){
      const q = quads[qi]; if (!q.chosen || cycleAbort) return {success:false};
      const duration = task?.duration || randInt(CHILL_WINDOW[0], CHILL_WINDOW[1]);
      await preCue(qi, 'CHILL', q.vibe.palette.base, 800);
      await showCue(qi, 'chill', EVENT_COLORS.chill, duration);
      return {success:true};
    }
    async function runAction(qi, label){
  const q = quads[qi]; if (!q.chosen || cycleAbort) return {success: false};
  const pal = q.vibe.palette; const clip = q.baseClip;

  await preCue(qi, 'ACTION', pal.base, Math.max(400, (q.vibe.precue||800)));

  await setClip(qi, clip, randomMidStart(clip));

  const el = q.overlays['action'];
  const inner = el.querySelector('.inner');

  inner.querySelector('.display-lg').textContent = label;

  hideAll(qi); pulseQuad(qi, pal.base);
  el.style.pointerEvents = 'none';
  el.classList.add('show');

  // Wait a moment then show buttons
  await waitForDuration(500);
  
  if (cycleAbort) return {success: false};
  const result = await showTaskButtons(qi);
  
  el.classList.remove('show');
  hideAll(qi);
  return result;
}


    
function showTaskButtons(qi){
  const q = quads[qi];
  return new Promise((resolve) => {
    let completed = false;
    let timeoutId = null;
    
    const cleanup = () => {
      q.taskButtons.classList.remove('show');
      if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }
      if (q.taskButtonTimeout) { clearTimeout(q.taskButtonTimeout); q.taskButtonTimeout = null; }
      q.btnTaskComplete.removeEventListener('click', onComplete);
      q.btnTaskFail.removeEventListener('click', onFail);
    };
    
    const onComplete = () => {
      if (completed) return;
      completed = true;
      cleanup();
      resolve({success: true});
    };
    
    const onFail = () => {
      if (completed) return;
      completed = true;
      cleanup();
      resolve({success: false});
    };
    
    q.btnTaskComplete.addEventListener('click', onComplete);
    q.btnTaskFail.addEventListener('click', onFail);
    q.taskButtons.classList.add('show');
    
    // Auto-hide after 5 seconds and count as success
    timeoutId = setTimeout(() => {
      if (!completed) {
        completed = true;
        cleanup();
        resolve({success: true});
      }
    }, 5000);
    
    q.taskButtonTimeout = timeoutId;
  });
}

function generateNextTask(vibe){
  const roll = Math.random();
  if (roll < 0.3) return {type:'puff'};
  if (roll < 0.55) return {type:'sniff', dur: vibe.sniff};
  if (roll < 0.8) return {type:'mask', duration: randInt(MASK_WINDOW[0], MASK_WINDOW[1])};
  return {type:'action', action: randomlySelectItem(ACTIONS)};
}

function buildQueue(vibe, counts={puff:5, sniff:8, action:5}){
  // Start with a small initial queue - will be replenished automatically
  const items = [];
  for(let i=0;i<3;i++) items.push(generateNextTask(vibe));
  return items;
}


    function renderPlanEmojis(queue){
      return queue.map(it=>EMOJI[it.type]||'‚Ä¢').join(' ');
    }

    function pauseAllTimers() {
      quads.forEach(q => {
        if (q.nextTaskTimer) { clearTimeout(q.nextTaskTimer); q.nextTaskTimer = null; }
        // remove visual target so RAF stops showing countdown
        q.nextTargetTime = null; q.nextGapMs = null;
        if(q.chosen && q.queue && q.queue.length > 0) q.nextTimer.textContent = 'PAUSED';
      });
    }
    function resumeAllTimers() {
      if (cycleAbort) return;
      quads.forEach(q => {
        if (q.chosen && q.queue && q.queue.length > 0) {
          q.scheduleNextTask(true); // true to reschedule immediately
        }
      });
    }

    
function scheduleNextTask(qi, reschedule = false){
  const q = quads[qi];
  if (q.nextTaskTimer) { clearTimeout(q.nextTaskTimer); q.nextTaskTimer = null; }
  q.nextTargetTime = null; q.nextGapMs = null;

  // Replenish queue if low - infinite task generation
  while (q.queue.length < 3) {
    q.queue.push(generateNextTask(q.vibe));
  }

  // Use a uniform gap between events (20s-120s) as requested
  const gapMs = reschedule ? 1000 : (20000 + Math.floor(Math.random() * 100000));

  const task = q.queue[0];
  const startTime = performance.now();
  const targetTime = startTime + gapMs;

  // store for RAF updater to display progress without per-quad interval
  q.nextTargetTime = targetTime;
  q.nextGapMs = gapMs;

  const timeoutId = setTimeout(async () => {
    // remove from active trackers immediately
    try{ activeIntervals.delete(timeoutId); }catch(e){}
    // clear visual tracking for this task
    q.nextTargetTime = null; q.nextGapMs = null; q.nextTaskTimer = null;

    if (cycleAbort || !q.chosen){
      return;
    }

    // If the UI shows a choice overlay or a global lock is held, delay execution
    if (!isEventReady()){
      // retry shortly
      const retry = setTimeout(()=> scheduleNextTask(qi, true), 1000);
      q.nextTaskTimer = retry;
      activeIntervals.add(retry);
      return;
    }

    // Acquire lock to prevent other quads starting at the same time
    globalEventLock = true;

    const actualTask = q.queue.shift();
    q.busy = true;
    q.currentTask = actualTask;

    let result = {success: false};
    try{
      if (actualTask.type === 'action'){
        q.nextTimer.textContent = 'ACTION IN PROGRESS...';
        result = await runAction(qi, actualTask.action.label);
        addTally(qi, 'action', result.success);
      } else if (actualTask.type === 'puff'){
        q.nextTimer.textContent = 'PUFF IN PROGRESS...';
        result = await runPuff(qi);
        addTally(qi, 'puff', result.success);
      } else if (actualTask.type === 'sniff'){
        q.nextTimer.textContent = 'SNIFF IN PROGRESS...';
        result = await runSniff(qi);
        addTally(qi, 'sniff', result.success);
      } else if (actualTask.type === 'mask'){
        q.nextTimer.textContent = 'MASK IN PROGRESS...';
        result = await runMask(qi, actualTask);
        addTally(qi, 'mask', result.success);
      } else if (actualTask.type === 'chill'){
        q.nextTimer.textContent = 'CHILLING...';
        result = await runChill(qi, actualTask);
        addTally(qi, 'chill', result.success);
      }
    } finally {
      // always release lock & busy state
      q.busy = false;
      q.currentTask = null;
      globalEventLock = false;
    }

    if (cycleAbort) return;
    scheduleNextTask(qi);

  }, gapMs);
  q.nextTaskTimer = timeoutId;
  // track timeout for potential cleanup
  activeIntervals.add(timeoutId);
}

    quads.forEach((q, i) => q.scheduleNextTask = (reschedule) => scheduleNextTask(i, reschedule));


    function startJitter(){
      // Cache quadrant references instead of querying DOM repeatedly
      const quadElements = document.querySelectorAll('.quadrant');
      const videoElements = Array.from(quadElements).map(q => q.querySelector('.quad-video'));
      
      const base = 0.985, span = 0.05 * (FURY.on?FURY.jitterAmp:1);
      return setInterval(()=>{
        for(let i = 0; i < quadElements.length; i++) {
          const s = base + Math.random()*span;
          quadElements[i].style.transform = 'scale('+s.toFixed(3)+')';
          if (videoElements[i]) {
            videoElements[i].style.transform = 'scale('+(1.03 - (s-1)).toFixed(3)+')';
          }
        }
      }, 1800);
    }

    function isEventReady() {
      return !cycleAbort && !globalEventLock && !document.querySelector('.action-choice-overlay.show') && !document.querySelector('.grid-choice-overlay.show');
    }

    // --- Grid Choice Function ---
    function startGridChoice(startedAt){
      let stop = false;
      async function loop(){
        await waitForDuration(40000 + Math.random()*40000); // 40-80 seconds
        if (!isEventReady()) return loop();

        const active = quads.map((q,i)=>({q,i})).filter(x=>x.q.chosen && !x.q.busy);
        if (!active.length) return loop();

        const {q, i} = randomlySelectItem(active);

      let choiceMade = false;
      let timerId = null;
      const overlay = q.el.querySelector('.grid-choice-overlay');
      const timerEl = overlay.querySelector('.grid-choice-timer');
      const gridItems = overlay.querySelectorAll('.grid-choice-item');        const currentUrl = q.baseClip.url;
        const pool = videos.filter(v => v.url !== currentUrl);
        const choices = [];
        let tempPool = [...pool];
        while(choices.length < 4 && tempPool.length > 0){
          const randIdx = Math.floor(Math.random() * tempPool.length);
          choices.push(tempPool.splice(randIdx, 1)[0]);
        }
        if (choices.length < 1) { challengeActive = false; resumeAllTimers(); return loop(); }

        const clickHandlers = [];
        choices.forEach((clip, idx) => {
          const item = gridItems[idx];
          if (!item) return;
          const v = item.querySelector('video');
          const label = item.querySelector('.item-label');
          v.onloadedmetadata = () => { v.currentTime = randomMidStart(clip); v.play().catch(()=>{}); };
          v.src = clip.url;
          label.textContent = convertToTitleCase(clip.name) || 'Video ' + (idx+1);
          item.style.display = 'block';

          const handler = async () => {
            choiceMade = true;
            q.baseClip = clip;
            q.label = convertToTitleCase(clip.name) || q.label;
            await setClip(i, clip, randomMidStart(clip));
            cleanup();
          };
          item.addEventListener('click', handler);
          clickHandlers.push({item, handler});
        });
        for(let j=choices.length; j<gridItems.length; j++) { gridItems[j].style.display = 'none'; }

        overlay.classList.add('show');

        let timeLeft = 20;
        timerEl.textContent = timeLeft;
        timerId = setInterval(() => {
          timeLeft--;
          timerEl.textContent = timeLeft;
          if (timeLeft <= 0) {
            clearInterval(timerId);
            cleanup();
          }
        }, 1000);

        function cleanup(){
          overlay.classList.remove('show');
          if (timerId) clearInterval(timerId);
          clickHandlers.forEach(h => h.item.removeEventListener('click', h.handler));
          gridItems.forEach(item => {
            const v = item.querySelector('video');
            if (v) { v.pause(); v.src = ''; }
          });
          resumeAllTimers();
        }

        loop();
      }
      loop();
      return ()=>{ stop=true; };
    }

    // --- Action Choice Function ---
    function startActionChoice(startedAt){
      let stop = false;
      async function loop(){
        if (stop) return;
        await waitForDuration(12000 + Math.random()*12000);
        if (stop) return;
        if (!isEventReady()) return loop();

        const active = quads.map((q,i)=>({q,i})).filter(x=>x.q.chosen && !x.q.busy && x.q.queue.length>0);
        if (!active.length) return loop();

        const {q} = randomlySelectItem(active);
        pauseAllTimers();

        let choiceMade = false;
        let cleaned = false;
        let timerId = null;

        const overlay = q.el.querySelector('.action-choice-overlay');
        const timerEl = overlay.querySelector('.action-choice-timer');
        const listEl = overlay.querySelector('.action-choice-list');
        listEl.innerHTML = '';

        const handlers = [];
        CHOICE_MENU.forEach(option=>{
          const item = document.createElement('div');
          item.className = 'action-choice-item';
          item.textContent = option.label;
          const handler = ()=>{
            if (choiceMade) return;
            choiceMade = true;
            const task = option.build();
            if (task.type === 'sniff' && !task.dur) task.dur = q.vibe.sniff;
            q.queue.unshift(task);
            cleanup();
          };
          item.addEventListener('click', handler);
          handlers.push({item, handler});
          listEl.appendChild(item);
        });

        overlay.classList.add('show');
        let timeLeft = 20;
        timerEl.textContent = timeLeft;

        timerId = setInterval(()=>{
          timeLeft--;
          timerEl.textContent = timeLeft;
          if (timeLeft <= 0){
            cleanup();
          }
        },1000);
        activeIntervals.add(timerId);

        function cleanup(){
          if (cleaned) return;
          cleaned = true;
          overlay.classList.remove('show');
          if (timerId){ clearInterval(timerId); activeIntervals.delete(timerId); timerId = null; }
          handlers.forEach(({item, handler})=> item.removeEventListener('click', handler));
          if (!choiceMade){
            q.queue.unshift({type:'chill', duration: randInt(CHILL_WINDOW[0], CHILL_WINDOW[1])});
          }
          resumeAllTimers();
        }

        loop();
      }
      loop();
      return ()=>{ stop = true; };
    }


    // --- Helper to populate grid choice
    function populateGrid(q, vids, overlay) {
        const gridItems = overlay.querySelectorAll('.grid-choice-item');
        const pool = [...vids];
        const choices = [];

        while(choices.length < 4 && pool.length > 0){
          const randIdx = Math.floor(Math.random() * pool.length);
          choices.push(pool.splice(randIdx, 1)[0]);
        }
        if (choices.length < 1) return;

        const clickHandlers = [];
        choices.forEach((clip, idx) => {
          const item = gridItems[idx];
          if (!item) return;
          const v = item.querySelector('video');
          const label = item.querySelector('.clip-label');
          v.onloadedmetadata = () => { v.currentTime = randomMidStart(clip); v.play().catch(()=>{}); };
          v.src = clip.url;
          label.textContent = convertToTitleCase(clip.name) || 'Video ' + (idx+1);
          item.style.display = 'block';

          const handler = async () => {
            q.baseClip = clip;
            q.label = convertToTitleCase(clip.name) || q.label;
            q.chooseTint.querySelector('.chooseTitle').textContent = q.label;
            overlay.classList.remove('show');
            clickHandlers.forEach(h => h.item.removeEventListener('click', h.handler));
          };
          item.addEventListener('click', handler);
          clickHandlers.push({item, handler});
        });
        for(let j=choices.length; j<gridItems.length; j++) { gridItems[j].style.display = 'none'; }
    }


    function setSoundFocus(qi){
      quads.forEach((q, idx)=>{
        const btn = q.el.querySelector('.btnSound');
        const on = idx===qi;
        q.video.muted = !on;
        btn.classList.toggle('active', on);
        btn.textContent = on ? 'üîä' : 'üîà';
      });
    }
    function fullscreenQuad(qi){
      const el = quads[qi].el; (el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen)?.call(el);
    }

    function manualSkip(qi) {
      const q = quads[qi];
      if (q.busy || !q.queue.length) return;
      // Skip current task and schedule next one immediately
      if (q.nextTaskTimer) {
        clearTimeout(q.nextTaskTimer);
        q.nextTaskTimer = null;
      }
      if (q.queue.length > 0) {
        q.queue.shift(); // Remove current task
      }
      q.scheduleNextTask(true); // Reschedule immediately
    }

    function manualShuffle(qi) {
      const q = quads[qi];
      if (!videos.length) return;
      const current = q.baseClip;
      const pool = videos.filter(v => v.url !== current.url);
      if (!pool.length) return;
      const newClip = pool[Math.floor(Math.random() * pool.length)];
      q.baseClip = newClip;
      q.label = convertToTitleCase(newClip.name) || q.label;
      setClip(qi, newClip, randomMidStart(newClip));
    }

    function stopAllLoops() {
        if (stopGridChoice) stopGridChoice();
        if (stopActionChoice) stopActionChoice();
        // Hide overlays and stop any playing preview videos; also remove attached handlers by cloning nodes
        document.querySelectorAll('.grid-choice-overlay, .action-choice-overlay').forEach(o=>{
          try{
            o.classList.remove('show');
            o.querySelectorAll('video').forEach(v=>{ try{ v.pause(); v.src = ''; }catch(e){} });
            const clone = o.cloneNode(true);
            o.parentNode.replaceChild(clone, o);
          }catch(e){}
        });
        // clear any tracked intervals/timeouts
        activeIntervals.forEach(id=>{ try{ clearTimeout(id); clearInterval(id); }catch(e){} });
        activeIntervals.clear();
    }

    async function startCycle(){
      cycleAbort = null;
      cycleEnded = false;
      stopAllLoops();

      const vids = videos.slice();
      const playerReady = [false, false];
      let allReady = false;

      for (let i=0;i<quads.length;i++){
        const q = quads[i];
        const el = q.el;
        q.baseClip = null;
        let currentVibeIdx = i % VIBES.length;

        q.vibe = JSON.parse(JSON.stringify(VIBES[currentVibeIdx]));

        el.classList.add('choose-phase');
        el.classList.add('selected');
        q.chosen = true;

        const chooseTint = q.chooseTint;
        const btnTheme = chooseTint.querySelector('.btn-change-theme');
        const btnPlayerStart = chooseTint.querySelector('.btn-player-start');
        const themeName = chooseTint.querySelector('.theme-name');
        const emojiPlanEl = chooseTint.querySelector('.emojisPlan');
        const clipGrid = chooseTint.querySelector('.clip-selection-grid');
        const clipOptions = clipGrid.querySelectorAll('.clip-option');
        
        let selectedClipIdx = 0;

        
const updateTheme = () => {
  q.vibe = JSON.parse(JSON.stringify(VIBES[currentVibeIdx]));

    // build initial queue (will auto-replenish)
    q.queue = buildQueue(q.vibe);
    q.completed = [];

    q.tally.textContent = 'Ready...';

    // Apply theme class to quadrant
    el.className = el.className.replace(/theme-\w+/, '');
    el.classList.add('theme-' + q.vibe.key);
    
    // Apply theme colors to various elements
    const pal = q.vibe.palette;
    chooseTint.style.background = `linear-gradient(120deg, ${pal.base}66, ${pal.accent}66)`;
    
    // Update theme name display
    themeName.textContent = q.vibe.key.toUpperCase();
    themeName.style.color = pal.accent;
    
    // Apply theme colors to UI elements
    q.nextTimer.style.borderColor = pal.base;
    q.nextTimer.style.background = `rgba(0,0,0,.7)`;
    q.nextBar.style.background = pal.accent;
    q.tally.style.borderColor = pal.base;
    q.selectBadge.style.background = `${pal.base}99`;
    
    // Set CSS custom property for this quadrant's theme
    el.style.setProperty('--themeBase', pal.base);
    el.style.setProperty('--themeAccent', pal.accent);
    el.style.setProperty('--themeDark', pal.dark);

    // hide the initial emoji plan (don't spoil order)
    emojiPlanEl.textContent = '';
};

// Populate clip selection grid
const first4Clips = vids.slice(0, 4);
clipOptions.forEach((option, idx) => {
  if (idx < first4Clips.length) {
    const clip = first4Clips[idx];
    const video = option.querySelector('video');
    const label = option.querySelector('.clip-label');
    
    video.src = clip.url;
    video.currentTime = randomMidStart(clip);
    video.play().catch(() => {});
    label.textContent = convertToTitleCase(clip.name);
    option.style.display = 'block';
    
    option.onclick = () => {
      clipOptions.forEach(opt => opt.classList.remove('selected'));
      option.classList.add('selected');
      selectedClipIdx = idx;
      q.baseClip = first4Clips[idx];
      q.label = convertToTitleCase(clip.name);
    };
  } else {
    option.style.display = 'none';
  }
});

// Select first clip by default
if (clipOptions.length > 0) {
  clipOptions[0].classList.add('selected');
  q.baseClip = first4Clips[0];
  q.label = convertToTitleCase(first4Clips[0].name);
}


        btnTheme.onclick = (e) => {
            e.stopPropagation();
            currentVibeIdx = (currentVibeIdx + 1) % VIBES.length;
            updateTheme();
        };
        
        btnPlayerStart.onclick = (e) => {
            e.stopPropagation();
            playerReady[i] = true;
            btnPlayerStart.disabled = true;
            btnPlayerStart.textContent = 'READY!';
            btnPlayerStart.style.opacity = '0.5';
            
            if (playerReady.every(ready => ready)) {
              allReady = true;
            }
        };
        
        updateTheme();
      }

      // Wait for all players to be ready
      while (!allReady && !cycleAbort) {
        await waitForDuration(100);
      }
      
      if (cycleAbort) return;

      document.querySelectorAll('.quadrant').forEach((el)=> el.classList.remove('choose-phase'));

      for (let i=0;i<quads.length;i++){
        const q = quads[i];
        
        // Stop clip selection videos
        const clipOptions = q.el.querySelectorAll('.clip-option video');
        clipOptions.forEach(v => { v.pause(); v.src = ''; });
        
        q.el.querySelector('.grid-choice-timer').style.display = 'block';
        q.el.querySelector('.grid-choice-title').textContent = "CHOOSE NEW VIDEO";

        q.el.classList.toggle('dimmed', !q.chosen);
        if (!q.chosen){
            q.video.pause();
            q.nextTimer.textContent='';
        } else {
            await setClip(i, q.baseClip, randomMidStart(q.baseClip));
            await waitForDuration(50);
        }
      }

      const begin = performance.now();
      const jitterId = startJitter();
      stopGridChoice = startGridChoice(begin);
      stopActionChoice = startActionChoice(begin);
      quads.forEach((q,i)=>{ if (q.chosen) q.scheduleNextTask(); });
      // start a single RAF-driven clock for countdown UI
      startGlobalClock();

      const stopHandler = () => {
        clearInterval(jitterId);
        stopAllLoops();
        stopGlobalClock();
        // clear any queued timeouts
        activeIntervals.forEach(id=>{ try{ clearTimeout(id); clearInterval(id); }catch(e){} });
        activeIntervals.clear();
        globalEventLock = false;
        document.removeEventListener('btnStopClicked', stopHandler);
      };
      document.addEventListener('btnStopClicked', stopHandler, {once: true});
    }

    function attachControls(){
      for (let i=0;i<quads.length;i++){
        const q = quads[i];
        const controls = document.querySelector('#q'+(i+1)+' .qcontrols');
        const btnOffset = controls.querySelector('.shuffleOffset');
        const btnVideo = controls.querySelector('.shuffleVideo');
        const btnFS = controls.querySelector('.btnFS');
        const btnSound = controls.querySelector('.btnSound');
        btnOffset.addEventListener('click', async ()=>{ await setClip(i, q.baseClip, randomMidStart(q.baseClip)); });
        btnVideo.addEventListener('click', async ()=>{
          if (!videos.length) return;
          const current = quads[i].baseClip; const pool = videos.filter(v=>v.url!==current.url); if (!pool.length) return;
          const newClip = pool[Math.floor(Math.random()*pool.length)];
          quads[i].baseClip = newClip; quads[i].label = convertToTitleCase(newClip.name) || quads[i].label; await setClip(i, newClip, randomMidStart(newClip));
        });
        btnFS.addEventListener('click', ()=> fullscreenQuad(i));
        btnSound.addEventListener('click', ()=> setSoundFocus(i));
        q.btnManualSkip.addEventListener('click', ()=> manualSkip(i));
        q.btnManualShuffle.addEventListener('click', ()=> manualShuffle(i));
      }
      btnFury.addEventListener('click', ()=>{
        FURY.on = !FURY.on; btnFury.classList.toggle('active', FURY.on); btnFury.textContent = FURY.on ? 'üî• Fury' : 'Fury Off';
      });
    }

    folderPicker.addEventListener('change', async (e) => {
      // revoke any previously created object URLs to avoid leaking memory
      try{ createdObjectURLs.forEach(u=>URL.revokeObjectURL(u)); }catch(e){}
      createdObjectURLs = [];

      const files = [...e.target.files].filter(f=>f.type.startsWith('video/'));
      if(files.length < 4){ status.textContent='Load at least 4 videos.'; return; }
      status.textContent='Loading videos‚Ä¶';
      videos = [];
      for(const f of files){
        const url = URL.createObjectURL(f);
        createdObjectURLs.push(url);
        const v = document.createElement('video');
        const duration = await new Promise(res=>{ v.onloadedmetadata=()=>res(v.duration||0); v.onerror=()=>res(0); v.preload='metadata'; v.src=url; });
        videos.push({url, duration: duration||0, name:f.name});
      }
      status.textContent = `Loaded ${videos.length} videos. Choose theme, clip, and press START.`;
      // Auto-start the setup phase
      startCycle();
    }, {passive:true});

    btnStart.addEventListener('click', ()=> { if (videos.length < 4){ status.textContent='Load at least 4 videos first.'; return; } startCycle(); });

    btnStop.addEventListener('click', ()=> {
      cycleAbort = true;
      document.dispatchEvent(new Event('btnStopClicked'));
      quads.forEach(q=>{
        if(q.ticker) try{ clearInterval(q.ticker); }catch(e){}
        if(q.nextTaskTimer) try{ clearTimeout(q.nextTaskTimer); }catch(e){}
        if(q.taskButtonTimeout) try{ clearTimeout(q.taskButtonTimeout); }catch(e){}
        q.nextTaskTimer = null; q.nextTargetTime = null; q.nextGapMs = null; q.taskButtonTimeout = null;
        q.nextTimer.textContent='';
        q.taskButtons.classList.remove('show');
        q.busy = false;
        q.currentTask = null;
      });
      // stop global UI clock and any background loops
      stopGlobalClock();
      stopAllLoops();

      // revoke created object URLs to free memory
      try{ createdObjectURLs.forEach(u=>URL.revokeObjectURL(u)); }catch(e){}
      createdObjectURLs = [];

      // clear any tracked intervals/timeouts
      activeIntervals.forEach(id=>{ try{ clearTimeout(id); clearInterval(id); }catch(e){} });
      activeIntervals.clear();

      // ensure global lock is cleared on stop
      globalEventLock = false;

      status.textContent='Stopped.';
      cycleEnded = false;
      document.querySelectorAll('.grid-choice-overlay, .action-choice-overlay').forEach(o => o.classList.remove('show'));
    });

    btnFSAll.addEventListener('click', ()=> { const el = document.documentElement; if (!document.fullscreenElement) el.requestFullscreen?.(); else document.exitFullscreen?.(); });
    btnMuteAll.addEventListener('click', ()=> { const anyMuted = quads.some(q=>q.video.muted); quads.forEach(q=> q.video.muted = !anyMuted); btnMuteAll.textContent = anyMuted ? 'üîä' : 'üîá'; });
    attachControls();
  })();
  </script>
</body>
</html>
