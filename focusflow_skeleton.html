<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FocusFlow - Breath Engine & Trivia</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    /* STYLE_CHUNK_1_BASE */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    :root {
      --bg: #0a0e1a;
      --fg: #e0e6ed;
      --panel: #1a1f2e;
      --accent: #4a90e2;
      --border: #2a3244;
      --themeAccent: #4a90e2;
      --themeBase: #1a1f2e;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      overflow: hidden;
    }
    
    #root {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    /* Top Bar */
    .top-bar {
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      padding: 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
    }
    
    .top-bar h1 {
      font-size: 1.5rem;
      color: var(--accent);
      margin: 0;
    }
    
    .score-display {
      font-size: 1.25rem;
      font-weight: bold;
      color: var(--fg);
    }
    
    /* Main Layout */
    .main-container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    
    .left-panel {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    
    .right-panel {
      width: 400px;
      background: var(--panel);
      border-left: 1px solid var(--border);
      overflow-y: auto;
      padding: 1rem;
    }
    
    /* Breath Engine Canvas */
    .breath-canvas-container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: var(--bg);
    }
    
    /* STYLE_CHUNK_2_TRIVIA_AND_SLOT */
    .trivia-panel {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    .trivia-question {
      background: var(--themeBase);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.5rem;
    }
    
    .trivia-question h3 {
      margin-bottom: 1rem;
      color: var(--accent);
    }
    
    .trivia-options {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .trivia-option {
      background: var(--panel);
      border: 2px solid var(--border);
      border-radius: 4px;
      padding: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.95rem;
    }
    
    .trivia-option:hover {
      border-color: var(--accent);
      background: var(--themeBase);
    }
    
    .trivia-option.correct {
      background: #2d5016;
      border-color: #4caf50;
    }
    
    .trivia-option.wrong {
      background: #5c1a1a;
      border-color: #f44336;
    }
    
    .trivia-stats {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--border);
      margin-bottom: 1rem;
    }
    
    .trivia-controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    
    button {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 0.5rem 1rem;
      cursor: pointer;
      font-size: 0.9rem;
      transition: opacity 0.2s;
    }
    
    button:hover {
      opacity: 0.8;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Slot Machine Styles */
    .slot-machine {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--panel);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      border: 2px solid var(--border);
    }
    
    .slot-reels {
      display: flex;
      gap: 0.25rem;
    }
    
    .slot-reel {
      width: 40px;
      height: 40px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: bold;
    }
    
    .slot-reel.spinning {
      animation: slot-spin 0.1s linear infinite;
    }
    
    @keyframes slot-spin {
      0% { transform: translateY(0); }
      100% { transform: translateY(-10px); }
    }
    
    .slot-button {
      background: var(--themeAccent);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: opacity 0.2s;
    }
    
    .slot-button:hover:not(:disabled) {
      opacity: 0.8;
    }
    
    .slot-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .slot-cost {
      font-size: 0.85rem;
      color: var(--fg);
      opacity: 0.8;
    }
    
    /* Lifeline Button Styles */
    .lifeline-buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }
    
    .lifeline-btn {
      flex: 1;
      min-width: 100px;
      background: var(--themeBase);
      border: 2px solid var(--accent);
      color: var(--fg);
      padding: 0.75rem 0.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: bold;
      transition: all 0.2s;
      position: relative;
    }
    
    .lifeline-btn:hover:not(:disabled) {
      background: var(--accent);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .lifeline-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      border-color: var(--border);
    }
    
    .lifeline-btn .badge {
      position: absolute;
      top: -8px;
      right: -8px;
      background: var(--accent);
      color: white;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: bold;
      border: 2px solid var(--bg);
    }
    
    .lifeline-btn.active {
      background: var(--accent);
      animation: lifeline-pulse 1s ease-in-out infinite;
    }
    
    @keyframes lifeline-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .effect-notice {
      background: rgba(74, 144, 226, 0.2);
      border: 1px solid var(--accent);
      border-radius: 4px;
      padding: 0.75rem;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      text-align: center;
    }
    
    @media (max-width: 768px) {
      .right-panel {
        width: 100%;
        max-height: 50vh;
      }
      
      .main-container {
        flex-direction: column;
      }
      
      .top-bar {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;
    
    // ============================================================================
    // CONSTANTS & CONFIGURATION
    // ============================================================================
    
    const DEBUG = true;
    const MAX_SPAWN_PER_SEC = 60;
    
    // Trivia Constants
    const TRIVIA_BASE_CORRECT = 100;
    const TRIVIA_MAX_SPEED_BONUS = 200;
    const TRIVIA_STREAK_BONUS_PER_Q = 50;
    const TRIVIA_WRONG_PENALTY = 500;
    const TRIVIA_QUESTIONS_PER_ROUND = 4;
    
    // Lifeline Types
    const LIFELINE_TYPES = {
      REMOVE_2: 'remove2',
      SKIP: 'skip',
      DOUBLE_Q: 'doubleQ',
      SAFE_WRONG: 'safeWrong'
    };
    
    // Slot Machine Configuration
    const SLOT_SYMBOLS = ['üéØ', 'üíé', '‚≠ê', 'üé∞', 'üçÄ', 'üí∞', 'üî•'];
    const SLOT_SPIN_INTERVAL_MS = 100;
    const SLOT_ANIM_MS = 1500;
    
    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================
    
    function debugLog(...args) {
      if (DEBUG) {
        console.log('[FocusFlow]', ...args);
      }
    }
    
    /**
     * Safely parse AI-generated content that might be a string or object
     * @param {string|object} rawContent - Raw content from AI API
     * @param {string} ctx - Context for logging
     * @returns {object|null} Parsed object or null on failure
     */
    function safeParseAIContent(rawContent, ctx = 'unknown') {
      try {
        if (typeof rawContent === 'object' && rawContent !== null) {
          return rawContent;
        }
        if (typeof rawContent === 'string') {
          const trimmed = rawContent.trim();
          // Handle potential markdown code blocks
          const match = trimmed.match(/^```(?:json)?\s*\n?([\s\S]*?)\n?```$/);
          const jsonStr = match ? match[1] : trimmed;
          return JSON.parse(jsonStr);
        }
        debugLog(`safeParseAIContent[${ctx}]: Invalid input type`, typeof rawContent);
        return null;
      } catch (err) {
        debugLog(`safeParseAIContent[${ctx}]: Parse error`, err.message);
        return null;
      }
    }
    
    /**
     * Create a breath engine with default state
     */
    function createBreathEngine() {
      return {
        shapes: [],
        clusters: [],
        nextShapeId: 0,
        nextClusterId: 0,
        paused: false
      };
    }
    
    /**
     * Create an initial cluster for the breath engine
     */
    function createInitialCluster(engine, centerX, centerY) {
      const cluster = {
        id: engine.nextClusterId++,
        centerX,
        centerY,
        radius: 100,
        color: '#4a90e2'
      };
      engine.clusters.push(cluster);
      return cluster;
    }
    
    /**
     * Fetch trivia questions from OpenTDB
     */
    async function fetchOpenTDBQuestions(categoryId, count = 10) {
      try {
        const url = `https://opentdb.com/api.php?amount=${count}${categoryId ? `&category=${categoryId}` : ''}&type=multiple`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.response_code !== 0 || !data.results) {
          debugLog('OpenTDB fetch failed:', data);
          return [];
        }
        
        return data.results.map(q => {
          const allOptions = [...q.incorrect_answers, q.correct_answer];
          // Shuffle options
          for (let i = allOptions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allOptions[i], allOptions[j]] = [allOptions[j], allOptions[i]];
          }
          
          return {
            question: decodeHTML(q.question),
            options: allOptions.map(decodeHTML),
            correctIndex: allOptions.indexOf(q.correct_answer),
            difficulty: q.difficulty
          };
        });
      } catch (err) {
        debugLog('fetchOpenTDBQuestions error:', err);
        return [];
      }
    }
    
    /**
     * Decode HTML entities
     */
    function decodeHTML(html) {
      const txt = document.createElement('textarea');
      txt.innerHTML = html;
      return txt.value;
    }
    
    /**
     * Mock AI functions (would need API keys in production)
     */
    async function generateTriviaBatchWithOpenAI(category, count) {
      debugLog('generateTriviaBatchWithOpenAI called (mock)');
      // In production, this would call OpenAI API
      // For now, return null to trigger fallback
      return null;
    }
    
    async function qualityCheckCategoriesWithOpenAI(categories) {
      debugLog('qualityCheckCategoriesWithOpenAI called (mock)');
      return null;
    }
    
    async function callGeminiJSON(prompt) {
      debugLog('callGeminiJSON called (mock)');
      return null;
    }
    
    // ============================================================================
    // BREATH ENGINE COMPONENT
    // ============================================================================
    
    function BreathEnginePanel({ addScore }) {
      const canvasRef = useRef(null);
      const engineRef = useRef(null);
      const animationFrameRef = useRef(null);
      const lastSpawnTimeRef = useRef(0);
      
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        
        // Initialize engine
        if (!engineRef.current) {
          engineRef.current = createBreathEngine();
          createInitialCluster(engineRef.current, canvas.width / 2, canvas.height / 2);
        }
        
        const resize = () => {
          canvas.width = canvas.offsetWidth;
          canvas.height = canvas.offsetHeight;
        };
        resize();
        window.addEventListener('resize', resize);
        
        // Animation loop
        const animate = (timestamp) => {
          const engine = engineRef.current;
          if (!engine || engine.paused) {
            animationFrameRef.current = requestAnimationFrame(animate);
            return;
          }
          
          ctx.fillStyle = 'rgba(10, 14, 26, 0.1)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Spawn new shapes occasionally
          /* RAF-based spawn accumulator guidance:
           * Track delta time between frames
           * Accumulate spawn budget based on MAX_SPAWN_PER_SEC
           * Spawn shapes when budget >= 1, decrement budget
           * This prevents spawning too many shapes in a single frame
           */
          const now = timestamp;
          if (now - lastSpawnTimeRef.current > 2000) {
            spawnBreathShape(engine, canvas.width, canvas.height);
            lastSpawnTimeRef.current = now;
          }
          
          // Update and draw shapes
          engine.shapes = engine.shapes.filter(shape => {
            shape.age++;
            shape.radius += 0.5;
            shape.opacity = Math.max(0, 1 - (shape.age / shape.maxAge));
            
            if (shape.opacity <= 0) return false;
            
            ctx.save();
            ctx.globalAlpha = shape.opacity;
            ctx.fillStyle = shape.color;
            ctx.beginPath();
            ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            return true;
          });
          
          animationFrameRef.current = requestAnimationFrame(animate);
        };
        
        animationFrameRef.current = requestAnimationFrame(animate);
        
        return () => {
          window.removeEventListener('resize', resize);
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
        };
      }, []);
      
      return (
        <div className="breath-canvas-container">
          <canvas ref={canvasRef} />
        </div>
      );
    }
    
    /**
     * Spawn a new breath shape with safety guards
     */
    function spawnBreathShape(engine, width, height) {
      // Safety guards
      if (!engine) {
        debugLog('spawnBreathShape: engine is null');
        return;
      }
      if (!engine.shapes) engine.shapes = [];
      if (!engine.clusters) engine.clusters = [];
      if (typeof engine.nextShapeId !== 'number') engine.nextShapeId = 0;
      if (typeof engine.nextClusterId !== 'number') engine.nextClusterId = 0;
      
      const shape = {
        id: engine.nextShapeId++,
        x: Math.random() * width,
        y: Math.random() * height,
        radius: 5 + Math.random() * 10,
        color: `hsl(${200 + Math.random() * 60}, 70%, 60%)`,
        opacity: 1,
        age: 0,
        maxAge: 100 + Math.random() * 100
      };
      
      engine.shapes.push(shape);
    }
    
    // ============================================================================
    // SLOT MACHINE COMPONENT
    // ============================================================================
    
    function SlotMachine({ onReward, score }) {
      const [reels, setReels] = useState(['üéØ', 'üéØ', 'üéØ']);
      const [spinning, setSpinning] = useState(false);
      const [spinCost] = useState(100);
      const spinTimerRef = useRef(null);
      
      const canSpin = score >= spinCost && !spinning;
      
      const handleSpin = useCallback(() => {
        if (!canSpin) return;
        
        setSpinning(true);
        onReward({ scoreDelta: -spinCost, type: 'spin' });
        
        let elapsed = 0;
        const interval = setInterval(() => {
          setReels([
            SLOT_SYMBOLS[Math.floor(Math.random() * SLOT_SYMBOLS.length)],
            SLOT_SYMBOLS[Math.floor(Math.random() * SLOT_SYMBOLS.length)],
            SLOT_SYMBOLS[Math.floor(Math.random() * SLOT_SYMBOLS.length)]
          ]);
          elapsed += SLOT_SPIN_INTERVAL_MS;
          
          if (elapsed >= SLOT_ANIM_MS) {
            clearInterval(interval);
            const finalReels = [
              SLOT_SYMBOLS[Math.floor(Math.random() * SLOT_SYMBOLS.length)],
              SLOT_SYMBOLS[Math.floor(Math.random() * SLOT_SYMBOLS.length)],
              SLOT_SYMBOLS[Math.floor(Math.random() * SLOT_SYMBOLS.length)]
            ];
            setReels(finalReels);
            setSpinning(false);
            
            // Check for wins
            if (finalReels[0] === finalReels[1] && finalReels[1] === finalReels[2]) {
              // Jackpot!
              const reward = { scoreDelta: 500, lifeline: null };
              if (Math.random() > 0.5) {
                const lifelines = Object.values(LIFELINE_TYPES);
                reward.lifeline = lifelines[Math.floor(Math.random() * lifelines.length)];
              }
              onReward(reward);
            } else if (finalReels[0] === finalReels[1] || finalReels[1] === finalReels[2]) {
              // Two match
              onReward({ scoreDelta: 50, lifeline: null });
            }
          }
        }, SLOT_SPIN_INTERVAL_MS);
      }, [canSpin, onReward, spinCost]);
      
      return (
        <div className="slot-machine">
          <div className="slot-reels">
            {reels.map((symbol, i) => (
              <div key={i} className={`slot-reel ${spinning ? 'spinning' : ''}`}>
                {symbol}
              </div>
            ))}
          </div>
          <button 
            className="slot-button" 
            onClick={handleSpin}
            disabled={!canSpin}
          >
            Spin
          </button>
          <div className="slot-cost">Cost: {spinCost}</div>
        </div>
      );
    }
    
    // ============================================================================
    // TRIVIA PANEL COMPONENT (WITH LIFELINE INTEGRATION)
    // ============================================================================
    
    function TriviaPanel({ addScore, lifelineInventory, onLifelineConsumed, lifelineEffects }) {
      const [questions, setQuestions] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [answered, setAnswered] = useState(false);
      const [selectedOption, setSelectedOption] = useState(null);
      const [streak, setStreak] = useState(0);
      const [loading, setLoading] = useState(false);
      const [hiddenOptions, setHiddenOptions] = useState(new Set());
      const questionStartTimeRef = useRef(null);
      
      const currentQuestion = questions[currentIndex];
      const isDoubleActive = lifelineEffects?.doubleQ || false;
      const isSafeActive = lifelineEffects?.safeWrong || false;
      
      useEffect(() => {
        loadQuestions();
      }, []);
      
      useEffect(() => {
        if (currentQuestion && !answered) {
          questionStartTimeRef.current = Date.now();
          setHiddenOptions(new Set());
        }
      }, [currentIndex, currentQuestion, answered]);
      
      const loadQuestions = async () => {
        setLoading(true);
        // Try OpenTDB first
        const triviaQuestions = await fetchOpenTDBQuestions(null, TRIVIA_QUESTIONS_PER_ROUND);
        
        if (triviaQuestions.length > 0) {
          setQuestions(triviaQuestions);
          setCurrentIndex(0);
          setAnswered(false);
        } else {
          // Fallback questions
          setQuestions([
            {
              question: 'What is the capital of France?',
              options: ['London', 'Berlin', 'Paris', 'Madrid'],
              correctIndex: 2,
              difficulty: 'easy'
            },
            {
              question: 'What is 2 + 2?',
              options: ['3', '4', '5', '6'],
              correctIndex: 1,
              difficulty: 'easy'
            }
          ]);
          setCurrentIndex(0);
          setAnswered(false);
        }
        setLoading(false);
      };
      
      const handleAnswer = (optionIndex) => {
        if (answered || hiddenOptions.has(optionIndex)) return;
        
        setAnswered(true);
        setSelectedOption(optionIndex);
        
        const isCorrect = optionIndex === currentQuestion.correctIndex;
        
        if (isCorrect) {
          // Calculate time bonus
          const timeElapsed = Date.now() - questionStartTimeRef.current;
          const speedBonus = Math.max(0, TRIVIA_MAX_SPEED_BONUS - Math.floor(timeElapsed / 100));
          const streakBonus = streak * TRIVIA_STREAK_BONUS_PER_Q;
          const multiplier = isDoubleActive ? 2 : 1;
          const totalScore = (TRIVIA_BASE_CORRECT + speedBonus + streakBonus) * multiplier;
          
          addScore(totalScore);
          setStreak(streak + 1);
        } else {
          if (!isSafeActive) {
            addScore(-TRIVIA_WRONG_PENALTY);
            setStreak(0);
          } else {
            // Safe wrong consumed - no penalty
            debugLog('Safe wrong lifeline protected from penalty');
          }
        }
        
        // Auto-advance after 2 seconds
        setTimeout(() => {
          if (currentIndex < questions.length - 1) {
            setCurrentIndex(currentIndex + 1);
            setAnswered(false);
            setSelectedOption(null);
          } else {
            loadQuestions();
          }
        }, 2000);
      };
      
      const handleLifeline = (type) => {
        if (!currentQuestion || answered) return;
        
        if (type === LIFELINE_TYPES.REMOVE_2) {
          // Remove 2 wrong answers
          const wrongIndices = currentQuestion.options
            .map((_, i) => i)
            .filter(i => i !== currentQuestion.correctIndex);
          
          const toRemove = wrongIndices.slice(0, 2);
          setHiddenOptions(new Set(toRemove));
          onLifelineConsumed(type);
        } else if (type === LIFELINE_TYPES.SKIP) {
          // Skip question
          if (currentIndex < questions.length - 1) {
            setCurrentIndex(currentIndex + 1);
            setAnswered(false);
            setSelectedOption(null);
          }
          onLifelineConsumed(type);
        } else if (type === LIFELINE_TYPES.DOUBLE_Q) {
          // Double points for next correct answer
          onLifelineConsumed(type);
        } else if (type === LIFELINE_TYPES.SAFE_WRONG) {
          // Safe wrong answer
          onLifelineConsumed(type);
        }
      };
      
      if (loading) {
        return <div className="trivia-panel"><p>Loading questions...</p></div>;
      }
      
      if (!currentQuestion) {
        return (
          <div className="trivia-panel">
            <button onClick={loadQuestions}>Load Questions</button>
          </div>
        );
      }
      
      return (
        <div className="trivia-panel">
          <div className="trivia-stats">
            <span>Q {currentIndex + 1}/{questions.length}</span>
            <span>Streak: {streak}</span>
          </div>
          
          {isSafeActive && (
            <div className="effect-notice">üõ°Ô∏è Safe Wrong Active - No penalty for wrong answer!</div>
          )}
          
          {isDoubleActive && (
            <div className="effect-notice">‚≠ê Double Points Active - 2x score this question!</div>
          )}
          
          <div className="trivia-question">
            <h3>{currentQuestion.question}</h3>
            <div className="trivia-options">
              {currentQuestion.options.map((option, i) => {
                if (hiddenOptions.has(i)) {
                  return (
                    <div key={i} className="trivia-option" style={{ opacity: 0.3, textDecoration: 'line-through' }}>
                      {option}
                    </div>
                  );
                }
                
                let className = 'trivia-option';
                if (answered) {
                  if (i === currentQuestion.correctIndex) {
                    className += ' correct';
                  } else if (i === selectedOption) {
                    className += ' wrong';
                  }
                }
                
                return (
                  <div 
                    key={i}
                    className={className}
                    onClick={() => handleAnswer(i)}
                  >
                    {option}
                  </div>
                );
              })}
            </div>
          </div>
          
          <div className="lifeline-buttons">
            <button
              className={`lifeline-btn ${isDoubleActive ? 'active' : ''}`}
              onClick={() => handleLifeline(LIFELINE_TYPES.REMOVE_2)}
              disabled={!lifelineInventory[LIFELINE_TYPES.REMOVE_2] || answered}
            >
              Remove 2
              {lifelineInventory[LIFELINE_TYPES.REMOVE_2] > 0 && (
                <span className="badge">{lifelineInventory[LIFELINE_TYPES.REMOVE_2]}</span>
              )}
            </button>
            
            <button
              className="lifeline-btn"
              onClick={() => handleLifeline(LIFELINE_TYPES.SKIP)}
              disabled={!lifelineInventory[LIFELINE_TYPES.SKIP] || answered}
            >
              Skip
              {lifelineInventory[LIFELINE_TYPES.SKIP] > 0 && (
                <span className="badge">{lifelineInventory[LIFELINE_TYPES.SKIP]}</span>
              )}
            </button>
            
            <button
              className={`lifeline-btn ${isDoubleActive ? 'active' : ''}`}
              onClick={() => handleLifeline(LIFELINE_TYPES.DOUBLE_Q)}
              disabled={!lifelineInventory[LIFELINE_TYPES.DOUBLE_Q] || answered}
            >
              Double Pts
              {lifelineInventory[LIFELINE_TYPES.DOUBLE_Q] > 0 && (
                <span className="badge">{lifelineInventory[LIFELINE_TYPES.DOUBLE_Q]}</span>
              )}
            </button>
            
            <button
              className={`lifeline-btn ${isSafeActive ? 'active' : ''}`}
              onClick={() => handleLifeline(LIFELINE_TYPES.SAFE_WRONG)}
              disabled={!lifelineInventory[LIFELINE_TYPES.SAFE_WRONG] || answered}
            >
              Safe Wrong
              {lifelineInventory[LIFELINE_TYPES.SAFE_WRONG] > 0 && (
                <span className="badge">{lifelineInventory[LIFELINE_TYPES.SAFE_WRONG]}</span>
              )}
            </button>
          </div>
          
          <div className="trivia-controls">
            <button onClick={loadQuestions}>New Round</button>
          </div>
        </div>
      );
    }
    
    // ============================================================================
    // MAIN APP COMPONENT
    // ============================================================================
    
    function App() {
      const [score, setScore] = useState(0);
      const [lifelineInventory, setLifelineInventory] = useState({
        [LIFELINE_TYPES.REMOVE_2]: 0,
        [LIFELINE_TYPES.SKIP]: 0,
        [LIFELINE_TYPES.DOUBLE_Q]: 0,
        [LIFELINE_TYPES.SAFE_WRONG]: 0
      });
      const [lifelineTimers, setLifelineTimers] = useState({
        [LIFELINE_TYPES.DOUBLE_Q]: null,
        [LIFELINE_TYPES.SAFE_WRONG]: null
      });
      
      const applyScoreDelta = useCallback((delta) => {
        setScore(prev => Math.max(0, prev + delta));
      }, []);
      
      const handleSlotReward = useCallback((reward) => {
        if (reward.scoreDelta) {
          applyScoreDelta(reward.scoreDelta);
        }
        if (reward.lifeline) {
          setLifelineInventory(prev => ({
            ...prev,
            [reward.lifeline]: prev[reward.lifeline] + 1
          }));
          debugLog('Lifeline awarded:', reward.lifeline);
        }
      }, [applyScoreDelta]);
      
      const consumeLifeline = useCallback((type) => {
        setLifelineInventory(prev => {
          if (prev[type] <= 0) return prev;
          return {
            ...prev,
            [type]: prev[type] - 1
          };
        });
        
        // Handle timed effects
        if (type === LIFELINE_TYPES.DOUBLE_Q || type === LIFELINE_TYPES.SAFE_WRONG) {
          setLifelineTimers(prev => ({
            ...prev,
            [type]: Date.now()
          }));
        }
      }, []);
      
      const getLifelineEffects = useCallback(() => {
        const now = Date.now();
        const effects = {};
        
        // Double Q lasts for one question (handled by TriviaPanel)
        if (lifelineTimers[LIFELINE_TYPES.DOUBLE_Q]) {
          effects.doubleQ = true;
        }
        
        // Safe Wrong lasts for one question (handled by TriviaPanel)
        if (lifelineTimers[LIFELINE_TYPES.SAFE_WRONG]) {
          effects.safeWrong = true;
        }
        
        return effects;
      }, [lifelineTimers]);
      
      // Clear timed lifeline effects after use
      useEffect(() => {
        if (lifelineTimers[LIFELINE_TYPES.DOUBLE_Q]) {
          const timer = setTimeout(() => {
            setLifelineTimers(prev => ({
              ...prev,
              [LIFELINE_TYPES.DOUBLE_Q]: null
            }));
          }, 30000); // 30 seconds max
          return () => clearTimeout(timer);
        }
      }, [lifelineTimers]);
      
      useEffect(() => {
        if (lifelineTimers[LIFELINE_TYPES.SAFE_WRONG]) {
          const timer = setTimeout(() => {
            setLifelineTimers(prev => ({
              ...prev,
              [LIFELINE_TYPES.SAFE_WRONG]: null
            }));
          }, 30000); // 30 seconds max
          return () => clearTimeout(timer);
        }
      }, [lifelineTimers]);
      
      return (
        <>
          <div className="top-bar">
            <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
              <h1>FocusFlow</h1>
              <SlotMachine onReward={handleSlotReward} score={score} />
            </div>
            <div className="score-display">Score: {score}</div>
          </div>
          
          <div className="main-container">
            <div className="left-panel">
              <BreathEnginePanel addScore={applyScoreDelta} />
            </div>
            <div className="right-panel">
              <TriviaPanel 
                addScore={applyScoreDelta}
                lifelineInventory={lifelineInventory}
                onLifelineConsumed={consumeLifeline}
                lifelineEffects={getLifelineEffects()}
              />
            </div>
          </div>
        </>
      );
    }
    
    // ============================================================================
    // RENDER APP
    // ============================================================================
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
